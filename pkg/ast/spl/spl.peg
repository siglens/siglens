{
// Copyright (c) 2021-2024 SigScalr, Inc.
//
// This file is part of SigLens Observability Solution
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Affero General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Affero General Public License for more details.
//
// You should have received a copy of the GNU Affero General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.

package spl

import (
    "regexp"
    "time"

    "github.com/siglens/siglens/pkg/ast"
    "github.com/siglens/siglens/pkg/segment/aggregations"
    "github.com/siglens/siglens/pkg/segment/query"
    "github.com/siglens/siglens/pkg/segment/structs"
    "github.com/siglens/siglens/pkg/segment/utils"
    toputils "github.com/siglens/siglens/pkg/utils"
    log "github.com/sirupsen/logrus"
)

func CalculateRelativeTime(timeModifier ast.TimeModifier, currTime time.Time) (int64, error) {
    var epoch int64 = 0
    var err error
    if timeModifier.AbsoluteTime == "now" {
        epoch = currTime.UnixMilli()
    } else if timeModifier.AbsoluteTime == "1" {
        return 1, nil
    } else if timeModifier.AbsoluteTime != "" {
        epoch, err = utils.ConvertCustomDateTimeFormatToEpochMs(timeModifier.AbsoluteTime)
        if err != nil {
            return 0, err
        }
    } else {
        offsetNum := timeModifier.RelativeTime.RelativeTimeOffset.Offset
        offsetTimeUnit := timeModifier.RelativeTime.RelativeTimeOffset.TimeUnit
        snap := timeModifier.RelativeTime.Snap
        finalTime := currTime
        if offsetNum != 0 {
            finalTime, err = utils.ApplyOffsetToTime(offsetNum, offsetTimeUnit, finalTime)
            if err != nil {
                return 0, err
            }
        }
        if snap != "" {
            finalTime, err = utils.ApplySnap(snap, finalTime)
            if err != nil {
                return 0, err
            }
        }
        epoch = finalTime.UnixMilli()
    }

    return epoch, nil
}

func applyTimeModifiers(initialEpoch int64, chainedOffsets []ast.RelativeTimeOffset, chainedSnaps []string) (int64, error) {
    offsetsLen := len(chainedOffsets)
    snapsLen := len(chainedSnaps)

    if offsetsLen != snapsLen {
        return 0, fmt.Errorf("chainedOffsets and chainedSnaps length not equal")
    }

    var err error
    for i := 0; i < offsetsLen; i++ {
        var relativeTimeModifier ast.RelativeTimeModifier

        relativeTimeModifier.RelativeTimeOffset = chainedOffsets[i]
        relativeTimeModifier.Snap = chainedSnaps[i]

        initialEpoch, err = CalculateRelativeTime(ast.TimeModifier{RelativeTime: relativeTimeModifier}, time.UnixMilli(initialEpoch))
        if err != nil {
            return 0, err
        }
    }
    return initialEpoch, nil
}

func getParseError(err error) error {
    switch ev := err.(type) {
    case errList:
        if pe, ok := ev[0].(*parserError); ok {
            return &ast.ParseError{
                Inner:    pe.Inner,
                Line:     pe.pos.line,
                Column:   pe.pos.col,
                Offset:   pe.pos.offset,
                Prefix:   pe.prefix,
                Expected: pe.expected,
            }
        }
    }
    return err
}

// Remove the first and last character of the string
func removeQuotes(s any) string {
    str := s.(string)
    if len(str) < 3 {
        return ""
    }

    return str[1:len(str)-1]
}

func GetAggregateFunction(funcName string) utils.AggregateFunctions {
    switch funcName {
    case "count", "c":
        return utils.Count 
    case "sum":
        return utils.Sum
    case "avg":
        return utils.Avg
    case "min":
        return utils.Min
    case "max":
        return utils.Max
    case "range":
        return utils.Range
    case "distinct_count", "dc":
        return utils.Cardinality
    case "values":
        return utils.Values
    case "list":
        return utils.List
    case "estdc":
        return utils.Estdc
    case "estdc_error":
        return utils.EstdcError
    case "median":
        return utils.Median
    case "mode":
        return utils.Mode
    case "stdev":
        return utils.Stdev
    case "stdevp":
        return utils.Stdevp
    case "sumsq":
        return utils.Sumsq
    case "var":
        return utils.Var
    case "varp":
        return utils.Varp
    case "first":
        return utils.First
    case "last":
        return utils.Last
    case "earliest":
        return utils.Earliest
    case "latest":
        return utils.Latest
    case "earliest_time":
        return utils.EarliestTime
    case "latest_time":
        return utils.LatestTime
    case "rate":
        return utils.StatsRate
    case "perc":
        return utils.Perc
    case "exactperc":
        return utils.ExactPerc
    case "upperperc":
        return utils.UpperPerc
    default:
        return utils.Invalid
    }
}

// Check if it rename fields with similar names using a wildcard
func isRegexRename(originalPattern, newPattern string) (bool, error) {
    oldWildcards := strings.Count(originalPattern, "*")
    newWildcards := strings.Count(newPattern, "*")

    if oldWildcards == 0 && newWildcards == 0 {
        return false, nil
    } else if oldWildcards > 0 && oldWildcards == newWildcards {
        return true, nil
    } else {
        return false, errors.New("Patterns do not match")
    }
}

func deMorgansLaw(node *ast.Node) {
    switch node.NodeType {
    case ast.NodeTerminal:
        switch node.Comparison.Op {
        case "=":
            node.Comparison.Op = "!="
        case "!=":
            node.Comparison.Op = "="
        case ">":
            node.Comparison.Op = "<="
        case "<":
            node.Comparison.Op = ">="
        case ">=":
            node.Comparison.Op = "<"
        case "<=":
            node.Comparison.Op = ">"
        default:
            log.Errorf("deMorgansLaw: unexpected node comparison op: %v", node.Comparison.Op)
        }
    case ast.NodeAnd:
        node.NodeType = ast.NodeOr
        deMorgansLaw(node.Left)
        deMorgansLaw(node.Right)
    case ast.NodeOr:
        node.NodeType = ast.NodeAnd
        deMorgansLaw(node.Left)
        deMorgansLaw(node.Right)
    default:
        log.Errorf("deMorgansLaw: unexpected NodeType: %v", node.NodeType)
    }
}

//Generate NumericExpr struct for eval functions
func createNumericExpr(op string, leftNumericExpr *structs.NumericExpr, rightNumericExpr *structs.NumericExpr, numericExprMode structs.NumericExprMode) (*structs.NumericExpr, error) {
    if leftNumericExpr == nil {
        return nil, fmt.Errorf("expr cannot be nil")
    }

    return &structs.NumericExpr{
        IsTerminal: false,
        Op: op,
        Left: leftNumericExpr,
        Right: rightNumericExpr,
        NumericExprMode: numericExprMode,
    }, nil
}

func transferUint8ToString(opName interface{}) (string, error){
    strData, ok := opName.([]byte)
    if !ok {
        return "", fmt.Errorf("opName is not a []byte")
    }

    opNameStr := string(strData)
    return opNameStr, nil
}

func transferPCREToRE2(pattern string) string {
    pattern = strings.Replace(pattern, "(?<", "(?P<", -1)
    return pattern
}

func getRexColNames(pattern string) ([]string, error) {
    re, err := regexp.Compile(`\?<(?P<GroupName>[a-zA-Z0-9_]+)>`)
    if err != nil {
        return nil, fmt.Errorf("getRexColNames: There are some errors in the pattern: %v", err)
    }
    matches := re.FindAllStringSubmatch(pattern, -1)

    var rexColNames []string
    for _, match := range matches {
        rexColNames = append(rexColNames, match[1])
    }

    return rexColNames, nil
}

func SearchMatchGetFields(searchStr string) ([]string, error) {

    kvPairs := strings.Fields(searchStr)
    if len(kvPairs) == 0 {
        return []string{}, fmt.Errorf("Spl peg: Invalid syntax for searchmatch")
    }
    fieldList := make([]string, 0)
    
    for _, kvPair := range kvPairs {
        parts := strings.Split(kvPair, "=")
        if len(parts) == 1 {
            if len(kvPairs) == 1 {
                fieldList = append(fieldList, "*")
                return fieldList, nil
            } else {
                return []string{}, fmt.Errorf("Spl peg: Invalid syntax for searchmatch") 
            }
        }
        if len(parts) != 2 {
            return []string{}, fmt.Errorf("Spl peg: Invalid syntax for searchmatch")
        }
        // fieldname is empty
        if len(parts[0]) == 0 {
            return []string{}, fmt.Errorf("Spl peg: Invalid syntax for searchmatch")
        }
        
        fieldList = append(fieldList, parts[0])
    }
    
    return fieldList, nil
}


func initializeStatsOptions() *structs.StatsOptions {
    return &structs.StatsOptions {
        Delim: " ",
        Partitions: 1,
        DedupSplitvals: false,
        Allnum: false,
    }
}

func initializeStreamStatsOptions() *structs.StreamStatsOptions {
    return &structs.StreamStatsOptions {
        Current: true,
        Global: true,
    }
}

func initializeGenTimesOption() (*structs.GenTimes, error) {
    endTime := time.Now()
    daySnap := fmt.Sprintf("%v", utils.TMDay)
    endTime, err := utils.ApplySnap(daySnap, endTime)
    if err != nil {
        return nil, fmt.Errorf("Spl peg: Error while applying the snap: %v", err)
    }

    return &structs.GenTimes{
        EndTime: uint64(endTime.UnixMilli()),
        Interval: &structs.SpanLength{
            Num: 1,
            TimeScalr: utils.TMDay,
        },
    }, nil
}

func createSPathExpr(inputField, pathField, outputField string) (*structs.QueryAggregators, error) {

    if inputField == "" {
        inputField = "_raw"
    }

    spathExpr := &structs.SPathExpr{
        InputColName: inputField,
        Path: pathField,
        OutputColName: outputField,
    }
    return &structs.QueryAggregators{
        PipeCommandType: structs.OutputTransformType,
        OutputTransforms: &structs.OutputTransforms{
            LetColumns: &structs.LetColumnsRequest{
                ValueColRequest: &structs.ValueExpr{
                    ValueExprMode: structs.VEMStringExpr,
                    StringExpr: &structs.StringExpr{
                        StringExprMode: structs.SEMTextExpr,
                        TextExpr: &structs.TextExpr{
                            IsTerminal: true,
                            Op: "spath",
                            SPathExpr: spathExpr,
                        },
                    },
                },
                NewColName: outputField,
            },
        },
    }, nil
}
func createEventCountExpr(indices []string, list_vix, report_size, summarize bool) (*structs.QueryAggregators, error) {
    eventCountExpr := &structs.EventCountExpr{
        Indices: indices,
        ListVix: list_vix,
        ReportSize: report_size,
        Summarize: summarize,
    }
    return &structs.QueryAggregators{
            PipeCommandType: structs.OutputTransformType,
            OutputTransforms: &structs.OutputTransforms{
                LetColumns: &structs.LetColumnsRequest{
                    EventCountRequest: eventCountExpr,
                },
            },
        }, nil
}
func getDefaultFormatResultsExpr() *structs.FormatResultsRequest {
    return &structs.FormatResultsRequest{
        MVSeparator: "OR",
        MaxResults: 0,
        EmptyString: "NOT()",
        RowColOptions: &structs.RowColOptions{
            RowPrefix: "(",
            ColumnPrefix: "(",
            ColumnSeparator: "AND",
            ColumnEnd: ")",
            RowSeparator: "OR",
            RowEnd: ")",
        },
    }
}

func chainAggregators(curQueryAgg *structs.QueryAggregators, queryAggs []any) {
    for ; curQueryAgg.Next != nil; curQueryAgg = curQueryAgg.Next {}

    // Link the remaining chains.
    for i := range queryAggs {
        queryAgg := queryAggs[i].(*structs.QueryAggregators)
        curQueryAgg.Next = queryAgg

        // Go to the end of this chain.
        for ; curQueryAgg.Next != nil; curQueryAgg = curQueryAgg.Next {}
    }
}

type aggregator struct {
    measureAgg          *structs.MeasureAggregator
    renameOutputField   bool
    outputFieldNewName  string
}

type singleAggTemp struct {
    aggregators []*aggregator
    SplitByClause *structs.SplitByClause
}

type TxnArgs struct {
    argOption string
    arguments *structs.TransactionArguments
}

type TimechartArgs struct {
    singleAggExpr *singleAggTemp
    // TODO: Add eval clause expr.
    tcOptions     *structs.TcOptions
}

type MultiValueColOptionArgs struct {
    argOption string
    mvColExpr *structs.MultiValueColLetRequest
}

type HeadOptionArgs struct {
    argOption string
    headExpr *structs.HeadExpr
}

type BinOptionArgs struct {
    argOption string
    binOptions *structs.BinCmdOptions
}

type StreamStatsOptionArgs struct {
    argOption string
    streamStatsOptions *structs.StreamStatsOptions
}

type GenTimesOptionArgs struct {
    argOption string
    genTimesOption *structs.GenTimes
}

type InputLookupOptionArgs struct {
    argOption string
    inputLookupOption *structs.InputLookup
}

type SPathFieldExpr struct {
    PathValue string
    IsPathFieldName bool  
}

type FormatResultsRequestArguments struct {
    argOption string
    formatResultExpr *structs.FormatResultsRequest
}

type StringSearchRequest struct {
    value interface{}
    originalValue interface{}
    caseInsensitive bool
}

}

Start <- indexBlock:(IndexBlock)? SPACE? initialSearch:(InitialSearchBlock) filterBlocks:(FilterBlock)* queryAggBlocks:(QueryAggergatorBlock)* SPACE? EOF {
    var q ast.QueryStruct
    q.SearchFilter = initialSearch.(*ast.Node)

    // Join the InitialSearchBlock with the FilterBlocks with AND nodes. For a
    // search like "A | B | C | D" we should generate the node structure below
    // so that when we run the search it evaluates A first.
    //
    //      AND
    //     /   \
    //    A     AND
    //         /   \
    //        B     AND
    //             /   \
    //            C     D

    filterBlocksSlice := filterBlocks.([]any)
    switch len(filterBlocksSlice) {
    case 0:
        q.SearchFilter = initialSearch.(*ast.Node)
    case 1:
        q.SearchFilter = &ast.Node {
            NodeType: ast.NodeAnd,
            Left: initialSearch.(*ast.Node),
            Right: filterBlocksSlice[0].(*ast.Node),
        }
    default: // len > 1
        // Iterate backwards so we build the node structure mentioned above.
        root := filterBlocksSlice[len(filterBlocksSlice) - 1].(*ast.Node)
        for i := len(filterBlocksSlice) - 2; i > -1; i-- {
            newRoot := &ast.Node {
                NodeType: ast.NodeAnd,
                Left: filterBlocksSlice[i].(*ast.Node),
                Right: root,
            }

            root = newRoot
        }

        q.SearchFilter = &ast.Node {
            NodeType: ast.NodeAnd,
            Left: initialSearch.(*ast.Node),
            Right: root,
        }
    }

    if queryAggBlocks != nil {
        queryAggSlice := queryAggBlocks.([]any)

        if len(queryAggSlice) > 0 {
            // Chain together all QueryAggergators.
            q.PipeCommands = queryAggSlice[0].(*structs.QueryAggregators)

            // Go to the end of the first chain.
            curQueryAgg := q.PipeCommands
            
            chainAggregators(curQueryAgg, queryAggSlice[1:])
        }
    }

    if indexBlock != nil {
        q.IndexNames = indexBlock.([]string)
    }

    return q, nil
}
/ SPACE? PIPE CMD_GENTIMES SPACE genTimesOption:(GenTimesOptionList) queryAggBlocks:(QueryAggergatorBlock)* SPACE? EOF {
    var q ast.QueryStruct
    q.PipeCommands = &structs.QueryAggregators{
        PipeCommandType: structs.GenerateEventType,
        GenerateEvent: &structs.GenerateEvent{
            GenTimes: genTimesOption.(*structs.GenTimes),
        },
        GentimesExpr: genTimesOption.(*structs.GenTimes),
    }

    if queryAggBlocks != nil {
        queryAggSlice := queryAggBlocks.([]any)
        curQueryAgg := q.PipeCommands

        chainAggregators(curQueryAgg, queryAggSlice)
    }

    return q, nil
}
/ SPACE? inputLookup:InputLookupBlock queryAggBlocks:(QueryAggergatorBlock)* SPACE? EOF {
    var q ast.QueryStruct
    q.PipeCommands = inputLookup.(*structs.QueryAggregators)

    if queryAggBlocks != nil {
        queryAggSlice := queryAggBlocks.([]any)
        curQueryAgg := q.PipeCommands

        chainAggregators(curQueryAgg, queryAggSlice)
    }

    return q, nil
}

IndexAssign <- index:("_index") EQUAL indexName:String {
    return removeQuotes(indexName), nil
}

// TODO: Allow for multiple operators (AND, NOT, parenthesis) and make it flexible so that it can be used anywhere in the search filter.
IndexExpression <- first:(IndexAssign) rest:(OR IndexAssign)* {
    
    if rest == nil {
        if first.(string) == "" {
            return []string{}, nil
        }
        return []string{first.(string)}, nil
    }

    finalIndexes := []string{}
    if first.(string) != "" {
        finalIndexes = append(finalIndexes, first.(string))
    }
    for _, v := range rest.([]any) {
        parts := v.([]any)  // This will be [OR, IndexAssign].
        index := parts[1].(string)
        if index == "" {
            continue
        }
        finalIndexes = append(finalIndexes, index)
    }

    return finalIndexes, nil
}

IndexBlock <- SPACE? indexName:(IndexExpression) PIPE? {
    return indexName, nil
}

PartialTimestamp <- [0-9][0-9] '/' [0-9][0-9] '/' [0-9][0-9][0-9][0-9] {
    timestamp := string(c.text)
    completeTimestamp := fmt.Sprintf("%s:00:00:00", timestamp)

    return completeTimestamp, nil
}

IntegerAsTimeToUnixEpochMs <- intStr:IntegerAsString {
    timeOffset, err := strconv.ParseInt(intStr.(string), 10, 64)
    if err != nil {
        return "", fmt.Errorf("Spl peg: Error while converting the integer: %v", err)
    }
    finalTime, err := utils.ApplyOffsetToTime(timeOffset, utils.TMDay, time.Now())
    if err != nil {
        return "", fmt.Errorf("Spl peg: Error while applying the offset: %v", err)
    }
    daySnap := fmt.Sprintf("%v", utils.TMDay)
    finalTime, err = utils.ApplySnap(daySnap, finalTime)
    if err != nil {
        return "", fmt.Errorf("Spl peg: Error while applying the snap: %v", err)
    }

    return finalTime.UnixMilli(), nil
}

DateTimeToUnixEpochMs <- timeStamp:(FullTimeStamp / PartialTimestamp) {
    unixEpochInMs, err := utils.ConvertCustomDateTimeFormatToEpochMs(timeStamp.(string))
    if err != nil {
        return "", fmt.Errorf("Spl peg: Error while converting the timestamp: %v", err)
    }
    return unixEpochInMs, nil
}


GenTimestamp <- epochInMilli:(DateTimeToUnixEpochMs / IntegerAsTimeToUnixEpochMs) {
    return epochInMilli, nil
}

GenTimesOptionEnd <- "end" EQUAL timeStamp:(GenTimestamp) {
    return &GenTimesOptionArgs{
        argOption: "end",
        genTimesOption: &structs.GenTimes{
            EndTime: uint64(timeStamp.(int64)),
        },
    }, nil
}

GenTimesOptionStart <- "start" EQUAL timeStamp:(GenTimestamp) {
    return &GenTimesOptionArgs{
        argOption: "start",
        genTimesOption: &structs.GenTimes{
            StartTime: uint64(timeStamp.(int64)),
        },
    }, nil
}

GenTimesOptionIncrement <- "increment" EQUAL intStr:IntegerAsString unitStr:("s" / "m" / "d" / "h")? {
    spanNum, err := strconv.ParseInt(intStr.(string), 10, 64)
    if err != nil {
        return "", fmt.Errorf("Spl peg: Error while converting the integer: %v", err)
    }
    if spanNum == 0 {
        return "", fmt.Errorf("Spl peg: increment cannot be 0")
    }

    timeUnit := utils.TMSecond

    if unitStr != nil {
        unit, err := transferUint8ToString(unitStr)
        if err != nil {
            return nil, fmt.Errorf("Spl peg: Unit specified is not string, err: %v", err)
        }

        if unit == "s" {
            timeUnit = utils.TMSecond
        } else if unit == "m" {
            timeUnit = utils.TMMinute
        } else if unit == "h" {
            timeUnit = utils.TMHour
        } else if unit == "d" {
            timeUnit = utils.TMDay
        } else {
            return nil, fmt.Errorf("Spl peg: Invalid time unit: %v", unit)
        }
    }

    return &GenTimesOptionArgs{
        argOption: "increment",
        genTimesOption: &structs.GenTimes{
            Interval: &structs.SpanLength{
                Num: int(spanNum),
                TimeScalr: timeUnit,
            },
        },
    }, nil
}

GenTimesOption <- genTimesOption:(GenTimesOptionEnd / GenTimesOptionStart / GenTimesOptionIncrement) {
    return genTimesOption, nil
}

GenTimesOptionList <- first:GenTimesOption rest:(SPACE GenTimesOption)* {
    restSlice := rest.([]any)
    optionWasSpecified := make(map[string]struct{})

    numOptions := 1 + len(restSlice)

    genTimeOption, err := initializeGenTimesOption()
    if err != nil {
        return nil, fmt.Errorf("Spl peg: Error while initializing the GenTimesOption: %v", err)
    }

    for i := 0; i < numOptions; i++ {
        var genTimeOptArg *GenTimesOptionArgs
        if i == 0 {
            genTimeOptArg = first.(*GenTimesOptionArgs)
        } else {
            separator := restSlice[i - 1].([]any)
            genTimeOptArg = separator[1].(*GenTimesOptionArgs)
        }

        argOption := genTimeOptArg.argOption
        _, exist := optionWasSpecified[argOption]
        if exist {
            return nil, fmt.Errorf("Invalid Syntax, option: %v is already specified", argOption)
        }
        optionWasSpecified[argOption] = struct{}{}

        switch argOption {
            case "start":
                genTimeOption.StartTime = genTimeOptArg.genTimesOption.StartTime
            case "end":
                genTimeOption.EndTime = genTimeOptArg.genTimesOption.EndTime
            case "increment":
                genTimeOption.Interval = genTimeOptArg.genTimesOption.Interval
            default:
                return nil, fmt.Errorf("Not a Valid GenTimes Command Option: %v", argOption)
        }
    }

    _, exist := optionWasSpecified["start"]
    if !exist {
        return nil, fmt.Errorf("Invalid Syntax, start time is not specified")
    }

    if genTimeOption.Interval.Num < 0 {
        genTimeOption.StartTime, genTimeOption.EndTime = genTimeOption.EndTime, genTimeOption.StartTime
		genTimeOption.Interval.Num = -genTimeOption.Interval.Num
    }

    return genTimeOption, nil
}

InitialSearchBlock <- CMD_SEARCH? clause:ClauseLevel4 {
    return clause, nil
}

SearchBlock <- !(ALLCMD) CMD_SEARCH? clause:ClauseLevel4 {
    return clause, nil
}

FilterBlock <- PIPE block:(SearchBlock / RegexBlock / TimeModifiers) {
    return block, nil
}

// Returns *structs.QueryAggregators
QueryAggergatorBlock <- block:(FieldSelectBlock / AggregatorBlock / EvalBlock / WhereBlock / HeadBlock / RexBlock / StatisticBlock / RenameBlock / TimechartBlock / TransactionBlock / DedupBlock / SortBlock / MultiValueBlock / SPathBlock / FormatBlock / EventCountBlock / TailBlock / BinBlock / StreamStatsBlock / FillNullBlock / MvexpandBlock / InputLookupAggBlock / AppendBlock) {
    queryAgg := block.(*structs.QueryAggregators)
    return queryAgg, nil
}

FieldSelectBlock <- PIPE CMD_FIELDS op:("-" / "+")? EMPTY_OR_SPACE fields:FieldNameList {
    columnsRequest := &structs.ColumnsRequest{}
    if op == nil || string(op.([]byte)) == "+" {
        columnsRequest.IncludeColumns = fields.([]string)
    } else {
        columnsRequest.ExcludeColumns = fields.([]string)
    }

    queryAggregator := &structs.QueryAggregators {
        PipeCommandType: structs.OutputTransformType,
        OutputTransforms: &structs.OutputTransforms {
            OutputColumns: columnsRequest,
        },
        FieldsExpr: columnsRequest,
    }

    return queryAggregator, nil
}

CommonAggregatorBlock <- aggs:AggregationList byFields:(GroupbyBlock)? {
    aggNode := &structs.QueryAggregators{}

    // Extract the MeasureAggregators and check if any of the aggregation fields
    // need to be renamed.
    aggsSlice := aggs.([]*aggregator)
    measureAggs := make([]*structs.MeasureAggregator, len(aggsSlice))
    columnsRequest := &structs.ColumnsRequest{}
    columnsRequest.RenameAggregationColumns = make(map[string]string, 0)

    for i, agg := range aggsSlice {
        measureAggs[i] = agg.measureAgg

        if agg.renameOutputField {
            columnsRequest.RenameAggregationColumns[measureAggs[i].String()] = agg.outputFieldNewName
        }
    }

    // If any agg field was renamed, make a QueryAggregators for all the renames.
    if len(columnsRequest.RenameAggregationColumns) > 0 {
        renameNode := &structs.QueryAggregators {
            PipeCommandType: structs.OutputTransformType,
            OutputTransforms: &structs.OutputTransforms {
                OutputColumns: columnsRequest,
            },
        }

        aggNode.Next = renameNode
    }

    if byFields == nil {
        aggNode.PipeCommandType = structs.MeasureAggsType
        aggNode.MeasureOperations = measureAggs
    } else {
        aggNode.PipeCommandType = structs.GroupByType
        aggNode.GroupByRequest = &structs.GroupByRequest {
            MeasureOperations: measureAggs,
            GroupByColumns: byFields.([]string),
        }
        aggNode.BucketLimit = query.MAX_GRP_BUCKS
    }

    return aggNode, nil
}


AggregatorBlock <- PIPE CMD_STATS aggs:(CommonAggregatorBlock) options:(StatsOptions)?{
    aggNode := aggs.(*structs.QueryAggregators)

    if options != nil {
        aggNode.StatsOptions = options.(*structs.StatsOptions)
    } else {
        aggNode.StatsOptions = initializeStatsOptions()
    }

    return aggNode, nil
}

// Todo: implement the processing logic
// Optional arguments for stats block
StatsOptions <- option:(StatsOption)*
{
    //Default value
    options := initializeStatsOptions()

    optionSlice := option.([]any)
    for _, opt := range optionSlice {
        optArr :=  opt.([]string)
        // Check for matching option types
        switch optArr[0] {
        case "dedup_splitvals":
            dedupSplitvalsBool, err := strconv.ParseBool(optArr[1])
            if err != nil {
                return nil, fmt.Errorf("Spl peg: StatsBlock: Options: invalid param for dedup_splitvals option, param: %v, err: %v", optArr[1], err)
            }
            options.DedupSplitvals = dedupSplitvalsBool
        case "partitions":
            pVal, err := strconv.ParseUint(optArr[1], 10, 64)
            if err != nil {
                return nil, fmt.Errorf("Spl peg: StatsBlock: Options: invalid param for partitions option, param: %v, err: %v", optArr[1], err)
            }
            options.Partitions = pVal
        case "allnum":
            allnumBool, err := strconv.ParseBool(optArr[1])
            if err != nil {
                return nil, fmt.Errorf("Spl peg: StatsBlock: Options: invalid param for allnum option, param: %v, err: %v", optArr[1], err)
            }
            options.Allnum = allnumBool
        case "delim":
            options.Delim = optArr[1]
        default:
            return nil, fmt.Errorf("Spl peg: StatisticBlock: Options: invalid option: %v", optArr[0])
        }
    }

    return options, nil
}

StatsOption <- SPACE optionCMD:StatsOptionCMD EQUAL str:(IntegerAsString / EvalFieldToRead / QuotedString) {
    optionArr := []string{optionCMD.(string), str.(string)}
    return optionArr, nil
}

StatsOptionCMD <- option:("allnum" / "dedup_splitvals" / "delim" / "partitions") {
    optionStr, err := transferUint8ToString(option)
    if err != nil {
        return nil, fmt.Errorf("Spl peg: StatsOptionCMD: %v", err)
    }
    return optionStr, nil
}

GroupbyBlock <- BY fields:FieldNameList {
    // Wildcard fields are not allowed. See https://docs.splunk.com/Documentation/Splunk/9.1.0/SearchReference/Stats
    for _, field := range fields.([]string) {
        if strings.Contains(field, "*") {
            return nil, errors.New("BY clause cannot contain fields with wildcards")
        }
    }

    return fields, nil
}


StreamStatsOptionResetOnChange <- "reset_on_change" EQUAL boolVal:Boolean {
    ssOption := &structs.StreamStatsOptions{
        ResetOnChange: boolVal.(bool),
    }
    ssOptionArg := &StreamStatsOptionArgs{
        argOption: "reset_on_change",
        streamStatsOptions: ssOption,
    }
    
    return ssOptionArg, nil
}

StreamStatsOptionCurrent <- "current" EQUAL boolVal:Boolean {
    ssOption := &structs.StreamStatsOptions{
        Current: boolVal.(bool),
    }
    ssOptionArg := &StreamStatsOptionArgs{
        argOption: "current",
        streamStatsOptions: ssOption,
    }
    
    return ssOptionArg, nil
}

StreamStatsOptionGlobal <- "global" EQUAL boolVal:Boolean {
    // TODO: Verify if needed, in splunk it does nothing as of now based on experiments.
    ssOption := &structs.StreamStatsOptions{
        Global: boolVal.(bool),
    }
    ssOptionArg := &StreamStatsOptionArgs{
        argOption: "global",
        streamStatsOptions: ssOption,
    }
    
    return ssOptionArg, nil
}

StreamStatsOptionAllNum <- "allnum" EQUAL boolVal:Boolean {
    // TODO: Verify if needed, in splunk it does nothing as of now based on experiments.
    ssOption := &structs.StreamStatsOptions{
        AllNum: boolVal.(bool),
    }
    ssOptionArg := &StreamStatsOptionArgs{
        argOption: "allnum",
        streamStatsOptions: ssOption,
    }
    
    return ssOptionArg, nil
}

StreamStatsOptionWindow <- "window" EQUAL windowSize:PositiveIntegerAsString {
    window, err := strconv.ParseUint(windowSize.(string), 10, 64)
    if err != nil {
        return nil, fmt.Errorf("Spl peg: Invalid window size: %v, must be a positive integer", windowSize.(string))
    }
    if window > 10000 {
        return nil, fmt.Errorf("Spl peg: Invalid window size: %v, must be less than or equal to 10000", window)
    }
    ssOption := &structs.StreamStatsOptions{
        Window: window,
    }
    ssOptionArg := &StreamStatsOptionArgs{
        argOption: "window",
        streamStatsOptions: ssOption,
    }
    
    return ssOptionArg, nil
}


StreamStatsOptionResetBefore <- "reset_before" EQUAL L_PAREN boolExpr:BoolExpr R_PAREN {
    ssOption := &structs.StreamStatsOptions{
        ResetBefore: boolExpr.(*structs.BoolExpr),
    }
    ssOptionArg := &StreamStatsOptionArgs{
        argOption: "reset_before",
        streamStatsOptions: ssOption,
    }
    
    return ssOptionArg, nil
}

StreamStatsOptionResetAfter <- "reset_after" EQUAL L_PAREN boolExpr:BoolExpr R_PAREN {
    ssOption := &structs.StreamStatsOptions{
        ResetAfter: boolExpr.(*structs.BoolExpr),
    }
    ssOptionArg := &StreamStatsOptionArgs{
        argOption: "reset_after",
        streamStatsOptions: ssOption,
    }
    
    return ssOptionArg, nil
}

StreamStatsOptionTimeWindow <- "time_window" EQUAL spanLength:BinSpanLenOption {
    spanLen := spanLength.(*structs.BinSpanLength)
    if spanLen.TimeScale == utils.TMInvalid {
        return nil, fmt.Errorf("Invalid Syntax, time_window option cannot be used without time scale")
    }
    ssOption := &structs.StreamStatsOptions{
        TimeWindow: spanLen,
    }
    ssOptionArg := &StreamStatsOptionArgs{
        argOption: "time_window",
        streamStatsOptions: ssOption,
    }
    
    return ssOptionArg, nil
}

StreamStatsOption <- ssOption:(StreamStatsOptionResetOnChange / StreamStatsOptionCurrent / StreamStatsOptionGlobal / StreamStatsOptionAllNum / StreamStatsOptionWindow / StreamStatsOptionResetBefore / StreamStatsOptionResetAfter / StreamStatsOptionTimeWindow) {
    return ssOption, nil
}

StreamStatsOptionList <- first:StreamStatsOption rest:(SPACE StreamStatsOption)* {
    restSlice := rest.([]any)
    optionWasSpecified := make(map[string]bool)

    numOptions := 1 + len(restSlice)

    ssOption := initializeStreamStatsOptions()

    for i := 0; i < numOptions; i++ {
        var ssOptArg *StreamStatsOptionArgs
        if i == 0 {
            ssOptArg = first.(*StreamStatsOptionArgs)
        } else {
            separator := restSlice[i - 1].([]any)
            ssOptArg = separator[1].(*StreamStatsOptionArgs)
        }

        argOption := ssOptArg.argOption
        val, exist := optionWasSpecified[argOption]
        if exist && val {
            return nil, fmt.Errorf("Invalid Syntax, option: %v is already specified", argOption)
        }
        optionWasSpecified[argOption] = true

        switch argOption {
            case "reset_on_change":
                ssOption.ResetOnChange = ssOptArg.streamStatsOptions.ResetOnChange
            case "current":
                ssOption.Current = ssOptArg.streamStatsOptions.Current
            case "global":
                ssOption.Global = ssOptArg.streamStatsOptions.Global
            case "allnum":
                ssOption.AllNum = ssOptArg.streamStatsOptions.AllNum
            case "window":
                ssOption.Window = ssOptArg.streamStatsOptions.Window
            case "time_window":
                ssOption.TimeWindow = ssOptArg.streamStatsOptions.TimeWindow
            case "reset_before":
                ssOption.ResetBefore = ssOptArg.streamStatsOptions.ResetBefore
            case "reset_after":
                ssOption.ResetAfter = ssOptArg.streamStatsOptions.ResetAfter
            default:
                return nil, fmt.Errorf("Not a Valid Streamstats Command Option: %v", argOption)
        }
    }

    timeWindowSpecified, exist := optionWasSpecified["time_window"]
    if exist && timeWindowSpecified {
        if !ssOption.Current {
            return nil, fmt.Errorf("Invalid Syntax, current cannot be set to false with time_window option")
        }
        if !ssOption.Global {
            return nil, fmt.Errorf("Invalid Syntax, global cannot be set to false with time_window option")
        }
    }

    return ssOption, nil
}

StreamStatsBlock <- PIPE CMD_STREAMSTATS ssOptionList:(StreamStatsOptionList) SPACE aggs:(CommonAggregatorBlock) {
    aggNode := aggs.(*structs.QueryAggregators)

    aggNode.StreamStatsOptions = ssOptionList.(*structs.StreamStatsOptions)

    return aggNode, nil
}
/ PIPE CMD_STREAMSTATS aggs:(CommonAggregatorBlock) {
    aggNode := aggs.(*structs.QueryAggregators)

    aggNode.StreamStatsOptions = initializeStreamStatsOptions()

    return aggNode, nil
}

RegexBlock <- CMD_REGEX keyAndOp:(FieldName EqualityOperator)? str:QuotedString {
    var key, op string
    if keyAndOp == nil {
        key = "*"
        op = "="
    } else {
        keyAndOpSlice := keyAndOp.([]any)
        key = keyAndOpSlice[0].(string)
        op = keyAndOpSlice[1].(string)
    }

    // Remove the quotation marks.
    regex := str.(string)
    regex = regex[1:len(regex) - 1]

    node := &ast.Node {
        NodeType: ast.NodeTerminal,
        Comparison: ast.Comparison {
            Op: op,
            Field: key,
            Values: regex,
            ValueIsRegex: true,
        },
    }

    return node, nil
}

ClauseLevel4 <- first:ClauseLevel3 rest:((AND / SPACE) ClauseLevel3)* {
    if rest == nil {
        return first, nil
    }

    cur := first.(*ast.Node)
    for _, v := range rest.([]any) {
        parts := v.([]any)  // This will be [(AND / SPACE), ClauseLevel3].
        cur = &ast.Node {
            NodeType: ast.NodeAnd,
            Left: cur,
            Right: parts[1].(*ast.Node),
        }
    }

    return cur, nil
}

ClauseLevel3 <- first:ClauseLevel2 rest:(OR ClauseLevel2)* {
    if rest == nil {
        return first, nil
    }

    cur := first.(*ast.Node)
    for _, v := range rest.([]any) {
        parts := v.([]any)  // This will be [OR, ClauseLevel2].
        cur = &ast.Node {
            NodeType: ast.NodeOr,
            Left: cur,
            Right: parts[1].(*ast.Node),
        }
    }

    return cur, nil
}

ClauseLevel2 <- notList:NOT+ first:ClauseLevel1 {
    // There's an issue with how queries with AST Not nodes are run, so use
    // De Morgan's law to manipulate the expression.
    node := first.(*ast.Node)
    numNots := len(notList.([]any))

    if numNots % 2 == 1 {
        deMorgansLaw(node)
    }

    return node, nil
} / clause:ClauseLevel1 {
    return clause, nil
}

ClauseLevel1 <- L_PAREN clause:ClauseLevel4 R_PAREN {
    return clause, nil
} / term:SearchTerm {
    return term, nil
}

// Parsing the text of a Number as a String would succeed, so we need to try
// parsing as a FieldWithNumberValue first.
SearchTerm <- term:(FieldWithNumberValue / FieldWithBooleanValue / FieldWithStringValue) {
    return term, nil
}

// To be finished: add (<eval-expression>) BY <split-by-clause> ) for expr; Limit option ...
TimechartBlock <- PIPE CMD_TIMECHART tcArgs:TimechartArgumentsList limitExpr:(LimitExpr)? {
    aggNode := &structs.QueryAggregators{}

    columnsRequest := &structs.ColumnsRequest{}
    columnsRequest.RenameAggregationColumns = make(map[string]string, 0)
    measureAggs := make([]*structs.MeasureAggregator, 0)

    timechartExpr := &structs.TimechartExpr{}
    byField := ""

    if tcArgs == nil {
        return nil, fmt.Errorf("spl peg: timechart: either single-agg or eval-expression by split-by-clause is required")
    }
    
    timechartArgs := tcArgs.(*TimechartArgs)
    
    // TODO: Should add || timechartArgs.evalExpr == nil
    if timechartArgs.singleAggExpr == nil {
        return nil, fmt.Errorf("spl peg: timechart: either single-agg or eval-expression by split-by-clause is required")
    }

    var bOptions *structs.BinOptions
    
    if timechartArgs.tcOptions != nil {
        if timechartArgs.tcOptions.BinOptions != nil {
            bOptions = timechartArgs.tcOptions.BinOptions
        }
    }

    if timechartArgs.singleAggExpr != nil {
        singleAgg := &structs.SingleAgg{}
        aggTemp := timechartArgs.singleAggExpr

        for i, agg := range aggTemp.aggregators {
            measureAggs = append(measureAggs, agg.measureAgg)

            if agg.renameOutputField {
                measureAggs[i].StrEnc = agg.outputFieldNewName
            }
        }

        singleAgg.MeasureOperations = measureAggs
        timechartExpr.SingleAgg = singleAgg

        if aggTemp.SplitByClause != nil {
            byField = aggTemp.SplitByClause.Field
        }
    }

    // TODO: if timechartArgs.evalExpr != nil {}

    aggNode.PipeCommandType = structs.GroupByType
    aggNode.GroupByRequest = &structs.GroupByRequest{
        MeasureOperations: measureAggs,
        GroupByColumns:    []string{"timestamp"},
    }
    aggNode.BucketLimit = query.MAX_GRP_BUCKS

    if bOptions == nil {
        bOptions = &structs.BinOptions{
            SpanOptions: &structs.SpanOptions{
                DefaultSettings: true,
                SpanLength: &structs.SpanLength{
                    Num: 1,
                    TimeScalr: utils.TMMinute,
                },
            },
        }
    }

    var limitExprTmp *structs.LimitExpr
    if limitExpr != nil {
        limitExprTmp = limitExpr.(*structs.LimitExpr)
        if len(measureAggs) > 1 {
            limitExprTmp.LimitScoreMode = structs.LSMByFreq
        }
    }

    timeBucket := aggregations.InitTimeBucket(bOptions.SpanOptions.SpanLength.Num, bOptions.SpanOptions.SpanLength.TimeScalr, byField, limitExprTmp, len(measureAggs))
    aggNode.TimeHistogram = timeBucket

    return aggNode, nil
}

// To be finished: <eval-expression> BY <split-by-clause>
// TimechartEvalExpr <- ... BY splitByClause:(SplitByClause) {
// }

TimechartArgumentsList <- first:TimechartArgument rest:(SPACE TimechartArgument)* {
    restSlice := rest.([]any)
    timechartArgs := &TimechartArgs{}

    numArgs := 1 + len(restSlice)

    for i :=0; i < numArgs; i++ {

        var numArg interface{}

        if i == 0 {
            numArg = first
        } else {
            numArg = restSlice[i - 1].([]any)[1]
        }

        switch numArg.(type) {
            case *singleAggTemp:
                timechartArgs.singleAggExpr = numArg.(*singleAggTemp)
            case *structs.TcOptions:
                timechartArgs.tcOptions = numArg.(*structs.TcOptions)
            default:
                return nil, fmt.Errorf("Spl peg: Timechart: invalid timechart argument: %v", numArg)
        }
    }
    
    return timechartArgs, nil
}

TimechartArgument <- tcArg:(SingleAggExpr / TcOptions) {
    return tcArg, nil
}

SingleAggExpr <- aggs:AggregationList splitByClause:SplitByClause? {
    singleAggExpr := &singleAggTemp {
        aggregators: aggs.([]*aggregator),
    }

    if splitByClause != nil {
        singleAggExpr.SplitByClause = splitByClause.(*structs.SplitByClause)
    }

    return singleAggExpr, nil
}

// Syntax: <field> (<tc-options>)... [<where-clause>]
// <where-clause> to be finished
SplitByClause <- BY field:FieldName {
    splitByClause := &structs.SplitByClause {
        Field: field.(string),
    }

    return splitByClause, nil
}

TcOptions <- option:(BinOptions / (TcOption)+) {
    //Default value
    tcOptions := &structs.TcOptions{
        UseNull: true,
        UseOther: true,
        NullStr: "null",
        OtherStr: "other",
    }
    switch option.(type) {
    case *structs.BinOptions:
        tcOptions.BinOptions = option.(*structs.BinOptions)
    case [][]string:
        optionSlice := option.([]any)
        for _, opt := range optionSlice {
            optArr := opt.([]string)
            switch optArr[0] {
                case "usenull":
                    useNullBool, err := strconv.ParseBool(optArr[1])
                    if err != nil {
                        return nil, fmt.Errorf("Spl peg: Timechart: TcOptions: %v", err)
                    }
                    tcOptions.UseNull = useNullBool
                case "useother":
                    useOtherBool, err := strconv.ParseBool(optArr[1])
                    if err != nil {
                        return nil, fmt.Errorf("Spl peg: Timechart: TcOptions: %v", err)
                    }
                    tcOptions.UseOther = useOtherBool
                case "nullstr":
                    tcOptions.OtherStr = optArr[1]
                case "otherstr":
                    tcOptions.OtherStr = optArr[1]
                default:
                    return nil, fmt.Errorf("Spl peg: Timechart: TcOptions: invalid option: %v", optArr[0])
            }
        }
    default:
        return nil, fmt.Errorf("Spl peg: Timechart: Invalid tcOptions %v", option)
    }
    return tcOptions, nil
}

TcOption <- SPACE tcOptionCMD:TcOptionCMD EQUAL val:EvalFieldToRead {
    tcOptionArr := []string{tcOptionCMD.(string), val.(string)}
    return tcOptionArr, nil
}

TcOptionCMD <- option:("usenull" / "useother" / "nullstr" / "otherstr") {
    optionStr, err := transferUint8ToString(option)
    if err != nil {
        return nil, fmt.Errorf("Spl peg: Timechart: TcOptionCMD: %v", err)
    }
    return optionStr, nil
}

AllTimeScale <- timeUnit:(Second / Month / Subseconds / Minute / Hour / Day / Week / Quarter / Year) {
    return timeUnit, nil
}

BinSpanLenOption <- number:(FloatAsString / IntegerAsString) timeScale:(AllTimeScale)? {
    if timeScale != nil {
        num, err := strconv.ParseInt(number.(string), 10, 64)
        if err != nil {
            return nil, fmt.Errorf("BinSpanLenOption: Invalid Number: %v is not an integer, err: %v", number.(string), err)
        }
        if num <= 0 {
            return nil, fmt.Errorf("BinSpanLenOption: Invalid span %v, span value must be greater than 0", num)
        }

        switch timeScale.(utils.TimeUnit) {
            case utils.TMDecisecond:
                if 10%num != 0 || num >= 10 {
                    return nil, fmt.Errorf("BinSpanLenOption: Invalid span for decisecond %v, span value must be less than 1 second and 1 second must be evenly divisble by span", num)
                }
            case utils.TMCentisecond:
                if 100%num != 0 || num >= 100 {
                    return nil, fmt.Errorf("BinSpanLenOption: Invalid span for centisecond %v, span value must be less than 1 second and 1 second must be evenly divisble by span", num)
                }
            case utils.TMMillisecond:
                if 1000%num != 0 || num >= 1000 {
                    return nil, fmt.Errorf("BinSpanLenOption: Invalid span for millisecond %v, span value must be less than 1 second and 1 second must be evenly divisble by span", num)
                }
            case utils.TMMicrosecond:
                return nil, fmt.Errorf("BinSpanLenOption: Invalid span microsecond is not supported!")
            case utils.TMMonth:
                if num > 12 || 12%num != 0 {
                    return nil, fmt.Errorf("BinSpanLenOption: Invalid span for month %v, span value must be less or equal to 1 year and 1 year must be evenly divisble by span", num)
                }
            case utils.TMQuarter:
                if num > 4 || 4%num != 0 {
                    return nil, fmt.Errorf("BinSpanLenOption: Invalid span for quarter %v, span value must be less or equal to 1 year and 1 year must be evenly divisble by span", num)
                }
        }

        spanLength := &structs.BinSpanLength {
            Num: float64(num),
            TimeScale: timeScale.(utils.TimeUnit),
        }

        return spanLength, nil
    } 

    num, err := strconv.ParseFloat(number.(string), 64)
    if err != nil {
        return nil, fmt.Errorf("BinSpanLenOption: Invalid Number: %v is not a numerical value, err: %v", number.(string), err)
    }
    if num <= 0.0 {
        return nil, fmt.Errorf("BinSpanLenOption: Invalid span %v, span value must be greater than 0", num)
    }

    spanLength := &structs.BinSpanLength {
        Num: num,
        TimeScale: utils.TMInvalid,
    }

    return spanLength, nil
}

BinOptionMinSpan <- "minspan" EQUAL spanLength:BinSpanLenOption {

    binOptionArgs := &BinOptionArgs {
        argOption: "minspan",
        binOptions: &structs.BinCmdOptions {
            MinSpan: spanLength.(*structs.BinSpanLength),
        },
    }
    return binOptionArgs, nil
}

BinOptionMaxBins <- "bins" EQUAL intAsStr:IntegerAsString {
    numBins, err := strconv.ParseUint(intAsStr.(string), 10, 64)
    if err != nil {
        return nil, fmt.Errorf("Invalid limit (%v): %v", intAsStr.(string), err)
    }
    if numBins < 2 || numBins > 50000 {
        return nil, fmt.Errorf("Invalid number of bins %v: must be between 2 and 50000", numBins)
    }
    binOptionArgs := &BinOptionArgs {
        argOption: "bins",
        binOptions: &structs.BinCmdOptions {
            MaxBins: numBins,
        },
    }
    return binOptionArgs, nil
}



// TODO: chain modifier and what else is supported?

BinOptionAlignTime <- "aligntime" EQUAL utcEpoch:(PositiveIntegerAsString) {
    epoch, err := strconv.ParseUint(utcEpoch.(string), 10, 64)
    if err != nil {
        return nil, fmt.Errorf("Spl peg: Invalid utc epoch value: %v for align time", utcEpoch.(string))
    }
    binOptionArgs := &BinOptionArgs {
        argOption: "aligntime",
        binOptions: &structs.BinCmdOptions {
            AlignTime: &epoch,
        },
    }

    return binOptionArgs, nil
}
/ "aligntime" EQUAL timestamp:(AbsoluteTimestamp / RelativeTimestamp) {
    var epoch uint64 = 0
    var err error
    relTimeModifier := timestamp.(ast.TimeModifier)
    epochVal, err := CalculateRelativeTime(relTimeModifier, time.Now())
    epoch = uint64(epochVal)
    if err != nil {
        return nil, err
    }

    binOptionArgs := &BinOptionArgs {
        argOption: "aligntime",
        binOptions: &structs.BinCmdOptions {
            AlignTime: &epoch,
        },
    }
    
    return binOptionArgs, nil
}

BinOptionStart <- "start" EQUAL number:(FloatAsString / IntegerAsString) {
    start, err := strconv.ParseFloat(number.(string), 64)
    if err != nil {
        return nil, fmt.Errorf("Spl peg: Cannot convert %v to float", number.(string))
    }
    binOptionArgs := &BinOptionArgs {
        argOption: "start",
        binOptions: &structs.BinCmdOptions {
            Start: &start,
        },
    }

    return binOptionArgs, nil
}

BinOptionEnd <- "end" EQUAL number:(FloatAsString / IntegerAsString) {
    end, err := strconv.ParseFloat(number.(string), 64)
    if err != nil {
        return nil, fmt.Errorf("Spl peg: Cannot convert %v to float", number.(string))
    }
    binOptionArgs := &BinOptionArgs {
        argOption: "end",
        binOptions: &structs.BinCmdOptions {
            End: &end,
        },
    }

    return binOptionArgs, nil
}

BinOptionSpan <- "span" EQUAL num1:(FloatAsString / IntegerAsString)? "log" num2:(FloatAsString / IntegerAsString)? {
    var coeff float64 = 1.0
    var base float64 = 10.0
    var err error

    if num2 != nil {
        base, err = strconv.ParseFloat(num2.(string), 64)
        if err != nil {
            return nil, fmt.Errorf("Spl peg: Invalid base in log span, %v cannot be converted to floar, err: %v", num2.(string), err)
        }
        if base <= 1.0 {
            return nil, fmt.Errorf("Spl peg: Invalid base in log span, base must be greater than 1")
        }
    }
    
    if num1 != nil {
        coeff, err = strconv.ParseFloat(num1.(string), 64)
        if err != nil {
            return nil, fmt.Errorf("Spl peg: Invalid coefficient in log span, %v cannot be converted to float, err: %v", num1.(string), err)
        }
        if coeff < 1.0 {
            return nil, fmt.Errorf("Spl peg: Invalid coefficient in log span, coefficient must be greater than or equal to 1")
        }
        if coeff >= base {
            return nil, fmt.Errorf("Spl peg: Invalid coefficient in log span, coefficient must be less than base")
        }
    }
    
    logSpan := &structs.LogSpan {
        Coefficient: coeff,
        Base: base,
    }
    spanOptions := &structs.BinSpanOptions {
        LogSpan: logSpan,
    }
    binOptionArgs := &BinOptionArgs {
        argOption: "span",
        binOptions: &structs.BinCmdOptions {
            BinSpanOptions: spanOptions,
        },
    }
    return binOptionArgs, nil
}
/ "span" EQUAL spanLen:BinSpanLenOption {

    spanOptions := &structs.BinSpanOptions {
        BinSpanLength: spanLen.(*structs.BinSpanLength),
    }

    binOptionArgs := &BinOptionArgs {
        argOption: "span",
        binOptions: &structs.BinCmdOptions {
            BinSpanOptions: spanOptions,
        },
    }
    return binOptionArgs, nil
} 

BinCmdOption <- option:(BinOptionAlignTime / BinOptionMinSpan / BinOptionMaxBins / BinOptionStart / BinOptionEnd / BinOptionSpan) {
    return option, nil
}

BinCmdOptionsList <- first: BinCmdOption rest: (SPACE BinCmdOption)* {
    restSlice := rest.([]any)
    optionWasSpecified := make(map[string]bool)

    numOptions := 1 + len(restSlice)

    binCmdOption := &structs.BinCmdOptions{}

    for i := 0; i < numOptions; i++ {
        var binOptArg *BinOptionArgs
        if i == 0 {
            binOptArg = first.(*BinOptionArgs)
        } else {
            separator := restSlice[i - 1].([]any)
            binOptArg = separator[1].(*BinOptionArgs)
        }

        argOption := binOptArg.argOption
        val, exist := optionWasSpecified[argOption]
        if exist && val {
            return nil, fmt.Errorf("Invalid Syntax, option: %v is already specified", argOption)
        }
        optionWasSpecified[argOption] = true

        switch argOption {
            case "minspan":
                binCmdOption.MinSpan = binOptArg.binOptions.MinSpan
            case "span":
                binCmdOption.BinSpanOptions = binOptArg.binOptions.BinSpanOptions
            case "bins":
                binCmdOption.MaxBins = binOptArg.binOptions.MaxBins
            case "start":
                binCmdOption.Start = binOptArg.binOptions.Start
            case "end":
                binCmdOption.End = binOptArg.binOptions.End
            case "aligntime":
                binCmdOption.AlignTime = binOptArg.binOptions.AlignTime
            default:
                return nil, fmt.Errorf("Not a Valid Bin Command Option: %v", argOption)
        }
    }

    return binCmdOption, nil
}


BinBlock <- PIPE CMD_BIN binCmdOption:(BinCmdOptionsList) SPACE field:FieldName newFieldName:(AsField)? {
    letColReq := &structs.LetColumnsRequest {
        NewColName: field.(string),
    }
    if newFieldName != nil {
        newName := newFieldName.(string)
        letColReq.NewColName = newName
        binOptions := binCmdOption.(*structs.BinCmdOptions)
        binOptions.NewFieldName = toputils.NewOptionWithValue(newName)
    }

    letColReq.BinRequest = binCmdOption.(*structs.BinCmdOptions)
    if letColReq.BinRequest.MaxBins == 0 {
        letColReq.BinRequest.MaxBins = 100
    }
    letColReq.BinRequest.Field = field.(string)

    queryAgg := &structs.QueryAggregators {
        PipeCommandType: structs.OutputTransformType,
        OutputTransforms: &structs.OutputTransforms {
            LetColumns: letColReq,
        },
        BinExpr: binCmdOption.(*structs.BinCmdOptions),
    }

    return queryAgg, nil
}
/ PIPE CMD_BIN field:FieldName newFieldName:(AsField)? {
    letColReq := &structs.LetColumnsRequest {
        NewColName: field.(string),
    }
    if newFieldName != nil {
        letColReq.NewColName = newFieldName.(string)
    }

    binCmdOption := &structs.BinCmdOptions{
        MaxBins: 100,
    }

    letColReq.BinRequest = binCmdOption
    letColReq.BinRequest.Field = field.(string)

    queryAgg := &structs.QueryAggregators {
        PipeCommandType: structs.OutputTransformType,
        OutputTransforms: &structs.OutputTransforms {
            LetColumns: letColReq,
        },
    }

    return queryAgg, nil
}


// To be finished: bins=<int> | minspan=<span-length> | span | <start-end>: (end=<num> | start=<num>) | aligntime=(earliest | latest | <time-specifier>)
BinOptions <- spanOptions:SpanOptions {
    binOptions := &structs.BinOptions {
        SpanOptions: spanOptions.(*structs.SpanOptions),
    }
    return binOptions, nil
}

// To be finished: span=<log-span> | span=<span-length> | span=<snap-to-time>
SpanOptions <- CMD_SPAN EQUAL spanLength:SpanLength {
    spanOptions := &structs.SpanOptions {
        SpanLength: spanLength.(*structs.SpanLength),
    }
    return spanOptions, nil
}

SpanLength <- intAsStr:IntegerAsString timeScale:AllTimeScale{
    if timeScale.(utils.TimeUnit) == utils.TMYear {
        return nil, fmt.Errorf("SpanLength: Invalid time unit, year is not supported")
    }
    num, err := strconv.Atoi(intAsStr.(string))
    if err != nil {
        return nil, fmt.Errorf("SpanLength: Invalid num (%v): %v", intAsStr.(string), err)
    }

    spanLength := &structs.SpanLength {
        Num: num,
        TimeScalr: timeScale.(utils.TimeUnit),
    }
    return spanLength, nil
}

// limit=topN keeps the N highest scoring distinct values of the split-by field
LimitExpr <- SPACE "limit" EQUAL sortBy:("top" / "bottom")? EMPTY_OR_SPACE intAsStr:(IntegerAsString){
    num, err := strconv.Atoi(intAsStr.(string))
    if err != nil {
        return nil, fmt.Errorf("SpanLength: Invalid num (%v): %v", intAsStr.(string), err)
    }

    limitExpr := &structs.LimitExpr {
        IsTop: true, // Default Value
        Num: num,
    }

    if sortBy != nil {
        sortByStr, err := transferUint8ToString(sortBy)
        if err != nil {
            return nil, fmt.Errorf("Spl peg: Timechart: %v", err)
        }
        if sortByStr == "bottom" {
            limitExpr.IsTop = false
        }
    }

    return limitExpr, nil
}

StatisticBlock <- PIPE statisticExpr:StatisticExpr {
    letColReq := &structs.LetColumnsRequest {
        StatisticColRequest: statisticExpr.(*structs.StatisticExpr),
    }

    root := &structs.QueryAggregators {
        PipeCommandType: structs.OutputTransformType,
        OutputTransforms: &structs.OutputTransforms {
            LetColumns: letColReq,
        },
    }

    measureAgg := &structs.MeasureAggregator {
        MeasureCol: "*",
        MeasureFunc: utils.Count,
    }

    measureOperations := make([]*structs.MeasureAggregator, 1)
    measureOperations[0] = measureAgg

    groupByColumns := append(statisticExpr.(*structs.StatisticExpr).FieldList, statisticExpr.(*structs.StatisticExpr).ByClause...)

    aggNode := &structs.QueryAggregators{}
    aggNode.Next = root
    aggNode.PipeCommandType = structs.GroupByType
    aggNode.GroupByRequest = &structs.GroupByRequest {
        MeasureOperations: measureOperations,
        GroupByColumns: groupByColumns,
    }

    return aggNode, nil
}

StatisticExpr <- cmd:(CMD_TOP / CMD_RARE) limit:(StatisticLimit)? fieldList:(SPACE FieldNameList) byClause:(ByClause)? options:(StatisticOptions)? {

    statisticExpr := &structs.StatisticExpr {
        FieldList: fieldList.([]interface{})[1].([]string),
    }

    statisticCmd, err := transferUint8ToString(cmd)
    if err != nil {
        return nil, fmt.Errorf("Spl peg: StatisticExpr: %v", err)
    }

    if(statisticCmd == "top"){
        statisticExpr.StatisticFunctionMode = structs.SFMTop
    } else {
        statisticExpr.StatisticFunctionMode = structs.SFMRare
    }

    if limit != nil {
        statisticExpr.Limit = limit.(string)
    }

    if options != nil {
        statisticExpr.StatisticOptions = options.(*structs.StatisticOptions)
    } else {
        statisticExpr.StatisticOptions = &structs.StatisticOptions {
            ShowCount: true,
            CountField: "count",
            ShowPerc: true,
            PercentField: "percent",
            UseOther: false,
            OtherStr: "Other",
        }
    }

    if byClause != nil {
        statisticExpr.ByClause = byClause.([]string)
    }

    return statisticExpr, nil
}

// Top limit=<int> is the same as specifying top N.
StatisticLimit <- SPACE number:IntegerAsString {
    return number.(string), nil
}
/ SPACE "limit" EQUAL limit:(IntegerAsString) {
    return limit.(string), nil
}

// Optional arguments for top/rare functions
StatisticOptions <- option:(StatisticOption)*
{
    //Default value
    options := &structs.StatisticOptions {
        ShowCount: true,
        CountField: "count",
        ShowPerc: true,
        PercentField: "percent",
        UseOther: false,
        OtherStr: "other",
    }

    optionSlice := option.([]any)
    for _, opt := range optionSlice {
        optArr :=  opt.([]string)
        // Check for matching option types
        switch optArr[0] {
        case "showcount":
            showCountBool, err := strconv.ParseBool(optArr[1])
            if err != nil {
                return nil, fmt.Errorf("Spl peg: StatisticBlock: Options: %v", err)
            }
            options.ShowCount = showCountBool
        case "countfield":
            options.CountField = optArr[1]
        case "showperc":
            showPercBool, err := strconv.ParseBool(optArr[1])
            if err != nil {
                return nil, fmt.Errorf("Spl peg: StatisticBlock: Options: %v", err)
            }
            options.ShowPerc = showPercBool
        case "percentfield":
            options.PercentField = optArr[1]
        case "useother":
            useOtherBool, err := strconv.ParseBool(optArr[1])
            if err != nil {
                return nil, fmt.Errorf("Spl peg: StatisticBlock: Options: %v", err)
            }
            options.UseOther = useOtherBool
        case "otherstr":
            options.OtherStr = optArr[1]
        default:
            return nil, fmt.Errorf("Spl peg: StatisticBlock: Options: invalid option")
        }
    }

    return options, nil
}

StatisticOption <- SPACE optionCMD:StatisticOptionCMD EQUAL field:EvalFieldToRead {
    optionArr := []string{optionCMD.(string), field.(string)}
    return optionArr, nil
}

StatisticOptionCMD <- option:("countfield" / "showcount" / "otherstr" / "useother"/ "percentfield" / "showperc") {
    optionStr, err := transferUint8ToString(option)
    if err != nil {
        return nil, fmt.Errorf("Spl peg: StatisticExpr: %v", err)
    }
    return optionStr, nil
}

ByClause <- BY fieldList:FieldNameList {
    return fieldList.([]string), nil
}
/ groupByBlock:GroupbyBlock {
    return groupByBlock.([]string), nil
}

DedupBlock <- PIPE CMD_DEDUP dedupExpr:DedupExpr {

    letColReq := &structs.LetColumnsRequest {
        DedupColRequest: dedupExpr.(*structs.DedupExpr),
    }

    root := &structs.QueryAggregators {
        PipeCommandType: structs.OutputTransformType,
        OutputTransforms: &structs.OutputTransforms {
            LetColumns: letColReq,
        },
        DedupExpr: dedupExpr.(*structs.DedupExpr),
    }

    return root, nil
}

// Returns *structs.DedupExpr
// It's not clear in the Splunk documentation whether the DedupOptions should
// be before or after the field list. However, the field list probably
// shouldn't be after the sortby clause.
DedupExpr <- limitArr:(SPACE IntegerAsString)? options1:(DedupOptions)? fieldList:(DedupFieldList)? options2:(DedupOptions)? sortByClause:(DedupSortByClause)? {
    dedupExpr := &structs.DedupExpr {
        FieldList: fieldList.([]string),
        Limit: 1,
        DedupCombinations: make(map[string]map[int][]structs.SortValue, 0),
        DedupRecords: make(map[string]map[string]interface{}, 0),
    }

    if limitArr != nil {
        limitStr := limitArr.([]interface{})[1].(string)
        limit, err := strconv.ParseUint(limitStr, 10, 64)
        if err != nil || limit == 0 {
            return nil, fmt.Errorf("Invalid limit (%v): %v", limitStr, err)
        }
        dedupExpr.Limit = limit
    }

    dedupExpr.DedupOptions = &structs.DedupOptions {
        Consecutive: false,
        KeepEmpty: false,
        KeepEvents: false,
    }

    if options1 != nil {
        dedupExpr.DedupOptions = options1.(*structs.DedupOptions)
    }
    if options2 != nil {
        options := options2.(*structs.DedupOptions)

        if options.Consecutive {
            dedupExpr.DedupOptions.Consecutive = options.Consecutive
        }
        if options.KeepEmpty {
            dedupExpr.DedupOptions.KeepEmpty = options.KeepEmpty
        }
        if options.KeepEvents {
            dedupExpr.DedupOptions.KeepEvents = options.KeepEvents
        }
    }

    if sortByClause != nil {
        dedupExpr.DedupSortEles = sortByClause.([]*structs.SortElement)

        // Make the DedupSortAscending from the DedupSortEles.
        dedupExpr.DedupSortAscending = make([]int, len(dedupExpr.DedupSortEles))
        for i, ele := range dedupExpr.DedupSortEles {
            if ele.SortByAsc {
                dedupExpr.DedupSortAscending[i] = 1
            } else {
                dedupExpr.DedupSortAscending[i] = -1
            }
        }
    }

    return dedupExpr, nil
}

DedupFieldName <- !("sortby") field:FieldName {
    return field, nil
}

// Parses one or more FieldNames separate by a space
// Returns a slice containing all the FieldNames
SpaceSeparatedFieldNameList <- first:FieldName !(EQUAL) rest:(SPACE FieldName !(EQUAL))* {
    var fields []string
    fields = append(fields, first.(string))
    for _, r := range rest.([]any) {
        // Extracting the field name from the tuple (SPACE, FieldName)
        fields = append(fields, r.([]any)[1].(string))
    }

    return fields, nil
}

DedupFieldList <- SPACE first:DedupFieldName rest:(SPACE DedupFieldName !EQUAL)* {
    // Convert `rest` to a slice. Each element of the slice will be a 2-element
    // slice where the first element is " " and the second is a FieldName.
    restSlice := rest.([]any)

    numFieldNames := 1 + len(restSlice)
    fields := make([]string, numFieldNames)
    fields[0] = first.(string)

    for i := 1; i < numFieldNames; i++ {
        separatorAndField := restSlice[i - 1].([]any)
        fields[i] = separatorAndField[1].(string)
    }

    return fields, nil
}

// Optional arguments for dedup block
DedupOptions <- option:(DedupOption)*
{
    //Default value
    options := &structs.DedupOptions {
        Consecutive: false,
        KeepEmpty: false,
        KeepEvents: false,
    }

    optionSlice := option.([]any)
    for _, opt := range optionSlice {
        optArr :=  opt.([]string)
        // Check for matching option types
        switch optArr[0] {
        case "consecutive":
            consecutiveBool, err := strconv.ParseBool(optArr[1])
            if err != nil {
                return nil, fmt.Errorf("Spl peg: DedupBlock: Options: %v", err)
            }
            options.Consecutive = consecutiveBool
        case "keepempty":
            keepEmptyBool, err := strconv.ParseBool(optArr[1])
            if err != nil {
                return nil, fmt.Errorf("Spl peg: DedupBlock: Options: %v", err)
            }
            options.KeepEmpty = keepEmptyBool
        case "keepevents":
            keepEventsBool, err := strconv.ParseBool(optArr[1])
            if err != nil {
                return nil, fmt.Errorf("Spl peg: DedupBlock: Options: %v", err)
            }
            options.KeepEvents = keepEventsBool
        default:
            return nil, fmt.Errorf("Spl peg: DedupBlock: Options: invalid option")
        }
    }

    return options, nil
}

DedupOption <- SPACE optionCMD:DedupOptionCMD "=" field:EvalFieldToRead {
    optionArr := []string{optionCMD.(string), field.(string)}
    return optionArr, nil
}

DedupOptionCMD <- option:("consecutive" / "keepempty" / "keepevents") {
    optionStr, err := transferUint8ToString(option)
    if err != nil {
        return nil, fmt.Errorf("Spl peg: DedupExpr: %v", err)
    }
    return optionStr, nil
}

DedupSortByClause <- CMD_DEDUP_SORTBY dedupSortEles:SortElements {
    return dedupSortEles, nil
}

// sortby ( - | + ) <sort-field> [(- | +) <sort_field> ...]
SortElements <- first:SingleSortElement rest:(SPACE_OR_COMMA SingleSortElement)* {
    restSlice := rest.([]any)

    length := 1 + len(restSlice)
    sortEles := make([]*structs.SortElement, length)
    sortEles[0] = first.(*structs.SortElement)

    for i := 1; i < length; i++ {
        elements := restSlice[i - 1].([]any)
        sortEles[i] = elements[1].(*structs.SortElement)
    }

    return sortEles, nil
}

SingleSortElement <- element:(SingleSortElementWithCast / SingleSortElementWithoutCast) {
    return element, nil
}

SingleSortElementWithoutCast <- sortBySymbol:("+" / "-" / "") field:FieldName {
    sortByAsc := true

    symbol := sortBySymbol.([]byte)
    if(len(symbol) > 0 && symbol[0] == '-') {
        sortByAsc = false
    }

    return &structs.SortElement {
        SortByAsc: sortByAsc,
        Op: "",
        Field: field.(string),
    }, nil
}

SingleSortElementWithCast <- sortBySymbol:("+" / "-" / "") op:("auto" / "str" / "ip" / "num") L_PAREN field:FieldName R_PAREN {
    sortByAsc := true

    symbol := sortBySymbol.([]byte)
    if(len(symbol) > 0 && symbol[0] == '-') {
        sortByAsc = false
    }

    opStr, err := transferUint8ToString(op)
    if err != nil {
        return nil, fmt.Errorf("Spl peg: singleSortElementWithCast: %v", err)
    }

    return &structs.SortElement {
        SortByAsc: sortByAsc,
        Op: opStr,
        Field: field.(string),
    }, nil
}

RenameBlock <- PIPE CMD_RENAME renameExpr:RenameExpr {
    letColReq := &structs.LetColumnsRequest {
        RenameColRequest: renameExpr.(*structs.RenameExpr),
    }

    root := &structs.QueryAggregators {
        PipeCommandType: structs.OutputTransformType,
        OutputTransforms: &structs.OutputTransforms {
            LetColumns: letColReq,
        },
    }

    return root, nil
}

// Rename with a phrase
RenameExpr <- originalPattern:RenamePattern AS newPattern:QuotedString {
    renameExpr := &structs.RenameExpr {
        RenameExprMode: structs.REMPhrase,
        OriginalPattern: originalPattern.(string),
        NewPattern: removeQuotes(newPattern),
    }

    return renameExpr, nil
}
// Rename fields with similar names using a wildcard
// Or Rename to a existing field
/ originalPattern:RenamePattern AS newPattern:RenamePattern {
    isRegex, err := isRegexRename(originalPattern.(string), newPattern.(string))
    if err != nil {
        return nil, fmt.Errorf("Spl peg: RenameExpr: %v", err)
    }

    var renameExprMode structs.RenameExprMode
    if isRegex {
        renameExprMode = structs.REMRegex
    } else {
        renameExprMode = structs.REMOverride
    }

    renameExpr := &structs.RenameExpr {
        RenameExprMode: renameExprMode,
        OriginalPattern: originalPattern.(string),
        NewPattern: newPattern.(string),
    }

    return renameExpr, nil
}

RexBlock <- PIPE CMD_REX "field" EQUAL field:EvalFieldToRead SPACE str:QuotedString {
    pattern := removeQuotes(str)
    rexColNames, err := getRexColNames(pattern)
    if err != nil {
        return nil, fmt.Errorf("Spl peg: RexBlock: %v", err)
    }
    rexExpr := &structs.RexExpr {
        FieldName: field.(string),
        Pattern: transferPCREToRE2(pattern),
        RexColNames: rexColNames,
    }

    letColReq := &structs.LetColumnsRequest {
        RexColRequest: rexExpr,
    }

    root := &structs.QueryAggregators {
        PipeCommandType: structs.OutputTransformType,
        OutputTransforms: &structs.OutputTransforms {
            LetColumns: letColReq,
        },
    }

    return root, nil
}

// arguments need to be finished:
// [<count>], [desc]
SortBlock <- PIPE CMD_SORT limit:(SortLimit)? sortByEles:SortElements {

    sortExpr := &structs.SortExpr {
        SortEles: sortByEles.([]*structs.SortElement),
        SortRecords: make(map[string]map[string]interface{}, 0),
        Limit: 10000,
    }

    if limit != nil {
        sortExpr.Limit = limit.(uint64)
    }

    ascendingArr := make([]int, len(sortExpr.SortEles))
    for i, ele := range sortExpr.SortEles {
        if ele.SortByAsc {
            ascendingArr[i] = 1
        } else {
            ascendingArr[i] = -1
        }
    }

    sortExpr.SortAscending = ascendingArr

    letColReq := &structs.LetColumnsRequest {
        SortColRequest: sortExpr,
    }

    root := &structs.QueryAggregators {
        PipeCommandType: structs.OutputTransformType,
        OutputTransforms: &structs.OutputTransforms {
            LetColumns: letColReq,
        },
        SortExpr: sortExpr,
    }

    return root, nil
}

SortLimit <- ("limit" EQUAL)? intAsStr:IntegerAsString SPACE {
    limit, err := strconv.ParseUint(intAsStr.(string), 10, 64)
    if err != nil {
        return nil, fmt.Errorf("Invalid limit (%v): %v", intAsStr.(string), err)
    }

    if limit == 0 {
        limit = math.MaxUint64
    }

    return limit, nil
}

// Returns *structs.QueryAggregators
EvalBlock <- PIPE CMD_EVAL first:SingleEval rest:(COMMA SingleEval)* {
    root := &structs.QueryAggregators {
        PipeCommandType: structs.OutputTransformType,
        OutputTransforms: &structs.OutputTransforms {
            LetColumns: first.(*structs.LetColumnsRequest),
        },
    }

    leafQueryAgg := root
    restSlice := rest.([]any)
    for i := range restSlice {
        CommaSpaceAndEval := restSlice[i].([]any)
        nextQueryAgg := &structs.QueryAggregators {
            PipeCommandType: structs.OutputTransformType,
            OutputTransforms: &structs.OutputTransforms {
                LetColumns: CommaSpaceAndEval[1].(*structs.LetColumnsRequest),
            },
        }

        leafQueryAgg.Next = nextQueryAgg
        leafQueryAgg = leafQueryAgg.Next
    }

    return root, nil
}

// Returns *structs.LetColumnsRequest
SingleEval <- field:FieldName EQUAL expr:EvalExpression {
    fieldStr := field.(string)
    if strings.Contains(fieldStr, "*") {
        return nil, fmt.Errorf("New fields must not contain wildcards; invalid field: %v", field)
    }

    letColumnsRequest := expr.(*structs.LetColumnsRequest)
    letColumnsRequest.NewColName = fieldStr

    return letColumnsRequest, nil
}

// Returns *structs.LetColumnsRequest without the NewColName set.
EvalExpression <- value:ValueExpr {
    letColReq := &structs.LetColumnsRequest {
        ValueColRequest: value.(*structs.ValueExpr),
    }

    return letColReq, nil
}

//TODO: implement the processing logic for: case, coalesce, validate, nullif
ConditionExpr <- "if" L_PAREN condition:BoolExpr COMMA trueValue:ValueExpr COMMA falseValue:ValueExpr R_PAREN {

    node := &structs.ConditionExpr {
        Op: "if",
        BoolExpr: condition.(*structs.BoolExpr),
        TrueValue: trueValue.(*structs.ValueExpr),
        FalseValue: falseValue.(*structs.ValueExpr),
    }

    return node, nil
}
/ opName:("case" / "validate") L_PAREN pair:ConditionValuePair rest:(COMMA ConditionValuePair)* R_PAREN {
    opNameStr, err := transferUint8ToString(opName)
    if err != nil {
        return nil, fmt.Errorf("Spl peg: ConditionExpr: %v", err)
    }
    pairs := make([]*structs.ConditionValuePair, 1)
    pairs[0] = pair.(*structs.ConditionValuePair)

    if rest != nil {
        restSlice := rest.([]any)
        for i := range restSlice {
            ele := restSlice[i].([]any)
            pairs = append(pairs, ele[1].(*structs.ConditionValuePair))
        }
    }

    node := &structs.ConditionExpr {
        Op: opNameStr,
        ConditionValuePairs: pairs,
    }

    return node, nil
}
/ "coalesce" L_PAREN valueExpr:ValueExpr rest:(COMMA ValueExpr)* R_PAREN {
    restSlice := rest.([]any)
    valueList := make([]*structs.ValueExpr, 1 + len(restSlice))
    valueList[0] = valueExpr.(*structs.ValueExpr)

    for i := range restSlice {
        valueAtom := restSlice[i].([]any)
        valueList[i + 1] = valueAtom[1].(*structs.ValueExpr)
    }

    node := &structs.ConditionExpr {
        Op: "coalesce",
        ValueList: valueList,
    }

    return node, nil
}
/ "nullif" L_PAREN leftValue:ValueExpr COMMA rightValue:ValueExpr R_PAREN {
    valueList := make([]*structs.ValueExpr, 2)
    valueList[0] = leftValue.(*structs.ValueExpr)
    valueList[1] = rightValue.(*structs.ValueExpr)

    node := &structs.ConditionExpr {
        Op: "nullif",
        ValueList: valueList,
    }

    return node, nil
}
/ "null" L_PAREN R_PAREN {
    node := &structs.ConditionExpr {
        Op: "null",
    }
    return node, nil
}

ConditionValuePair <- condition:BoolExpr COMMA value:ValueExpr {
    conditionValuePair := &structs.ConditionValuePair {
        Condition: condition.(*structs.BoolExpr),
        Value: value.(*structs.ValueExpr),
    }
    return conditionValuePair, nil
}

StringExprAsValueExpr <- stringExpr:StringExpr {
    strExpr := stringExpr.(*structs.StringExpr)
    valueExpr := &structs.ValueExpr{
        ValueExprMode: structs.VEMStringExpr,
        StringExpr: strExpr,
    }

    return valueExpr, nil
}

MultiValueExprAsValueExpr <- multiValueExpr:MultiValueExpr {
    valueExpr := &structs.ValueExpr{
        ValueExprMode: structs.VEMMultiValueExpr,
        MultiValueExpr: multiValueExpr.(*structs.MultiValueExpr),
    }

    return valueExpr, nil
}

StringOrMultiValueExpr <- strOrMVExpr:(MultiValueExprAsValueExpr / StringExprAsValueExpr) {
    return strOrMVExpr.(*structs.ValueExpr), nil
}

MultiValueExpr <- (opName:("split") L_PAREN stringExpr:StringExpr COMMA delim:StringExpr R_PAREN) {
    opNameStr, err := transferUint8ToString(opName)
    if err != nil {
        return nil, fmt.Errorf("Spl peg: MultiValueExpr: %v", err)
    }
    node := &structs.MultiValueExpr {
        Op: opNameStr,
        StringExprParams: []*structs.StringExpr{stringExpr.(*structs.StringExpr), delim.(*structs.StringExpr)},
    }

    return node, nil
}
/ (opName:("mvindex") L_PAREN multiValueExpr:MultiValueExpr COMMA startIndex:NumericExpr endIndex:(NumericParamExpr)? R_PAREN) {
    opNameStr, err := transferUint8ToString(opName)
    if err != nil {
        return nil, fmt.Errorf("Spl peg: MultiValueExpr: %v", err)
    }
    node := &structs.MultiValueExpr {
        Op: opNameStr,
        NumericExprParams: []*structs.NumericExpr{startIndex.(*structs.NumericExpr)},
        MultiValueExprParams: []*structs.MultiValueExpr{multiValueExpr.(*structs.MultiValueExpr)},
    }
    if endIndex != nil {
        node.NumericExprParams = append(node.NumericExprParams, endIndex.(*structs.NumericExpr))
    }

    return node, nil
}
/ (opName:("mvdedup" / "mvsort") L_PAREN multiValueExpr:MultiValueExpr R_PAREN) {
    opNameStr, err := transferUint8ToString(opName)
    if err != nil {
        return nil, fmt.Errorf("Spl peg: MultiValueExpr: %v", err)
    }
    node := &structs.MultiValueExpr {
        Op: opNameStr,
        MultiValueExprParams: []*structs.MultiValueExpr{multiValueExpr.(*structs.MultiValueExpr)},
    }

    return node, nil
}
/ (opName:("mvfilter") L_PAREN condition:BoolExpr R_PAREN) {
    opNameStr, err := transferUint8ToString(opName)
    if err != nil {
        return nil, fmt.Errorf("Spl peg: MultiValueExpr: Failed to recognize operator: %v, err= %v", opName, err)
    }

    node := &structs.MultiValueExpr {
        Op: opNameStr,
        Condition: condition.(*structs.BoolExpr),
    }

    return node, nil
}
/ (opName:("mvmap") L_PAREN multiValueExpr:MultiValueExpr COMMA expr:ValueExpr R_PAREN) {
    opNameStr, err := transferUint8ToString(opName)
    if err != nil {
        return nil, fmt.Errorf("Spl peg: MultiValueExpr: %v", err)
    }
    node := &structs.MultiValueExpr {
        Op: opNameStr,
        MultiValueExprParams: []*structs.MultiValueExpr{multiValueExpr.(*structs.MultiValueExpr)},
        ValueExprParams: []*structs.ValueExpr{expr.(*structs.ValueExpr)},
    }

    return node, nil
}
/ (opName:("mvrange") L_PAREN startIndex:NumericExpr COMMA endIndex:NumericExpr COMMA stringExpr:(StringExpr)? R_PAREN) {
    opNameStr, err := transferUint8ToString(opName)
    if err != nil {
        return nil, fmt.Errorf("Spl peg: MultiValueExpr: %v", err)
    }
    node := &structs.MultiValueExpr {
        Op: opNameStr,
        NumericExprParams: []*structs.NumericExpr{startIndex.(*structs.NumericExpr), endIndex.(*structs.NumericExpr)},
        StringExprParams: []*structs.StringExpr{stringExpr.(*structs.StringExpr)},
    }

    return node, nil
}
/ (opName:("mvzip") L_PAREN mvLeft:MultiValueExpr COMMA mvRight:MultiValueExpr rest:(COMMA StringExpr)? R_PAREN ) {
    opNameStr, err := transferUint8ToString(opName)
    if err != nil {
        return nil, fmt.Errorf("Spl peg: MultiValueExpr: %v", err)
    }
    node := &structs.MultiValueExpr {
        Op: opNameStr,
        MultiValueExprParams: []*structs.MultiValueExpr{mvLeft.(*structs.MultiValueExpr), mvRight.(*structs.MultiValueExpr)},
    }

    if rest != nil {
        restSlice := rest.([]any)
        node.StringExprParams = []*structs.StringExpr{restSlice[1].(*structs.StringExpr)}
    }

    return node, nil
}
/ (opName:("mv_to_json_array") L_PAREN multiValueExpr:MultiValueExpr rest:(COMMA ("true" / "false") "()")? R_PAREN ) {
    opNameStr, err := transferUint8ToString(opName)
    if err != nil {
        return nil, fmt.Errorf("Spl peg: MultiValueExpr: %v", err)
    }

    node := &structs.MultiValueExpr {
        Op: opNameStr,
        MultiValueExprParams: []*structs.MultiValueExpr{multiValueExpr.(*structs.MultiValueExpr)},
        InferTypes: false, // default value
    }

    if rest != nil {
        restSlice := rest.([]any)
        inferTypes, err := transferUint8ToString(restSlice[1])
        if err != nil {
            return nil, fmt.Errorf("Spl peg: MultiValueExpr: %v", err)
        }
        if inferTypes == "true" {
            node.InferTypes = true
        }
    }

    return node, nil
}
/ (opName:("mvappend") L_PAREN firstVal:StringOrMultiValueExpr rest:(COMMA StringOrMultiValueExpr)* R_PAREN ) {
    opNameStr, err := transferUint8ToString(opName)
    if err != nil {
        return nil, fmt.Errorf("Spl peg: MultiValueExpr: %v", err)
    }
    node := &structs.MultiValueExpr {
        Op: opNameStr,
        ValueExprParams: []*structs.ValueExpr{firstVal.(*structs.ValueExpr)},
    }

    if rest != nil {
        restSlice := rest.([]any)
        for i := range restSlice {
            valueExprAtom := restSlice[i].([]any)
            node.ValueExprParams = append(node.ValueExprParams, valueExprAtom[1].(*structs.ValueExpr))
        }
    }

    return node, nil
}
/ field:EvalFieldToRead !(OpPlus / OpMinus / OpMul / OpDiv / OpMod / EVAL_CONCAT / "(") {
    expr := &structs.MultiValueExpr {
        MultiValueExprMode: structs.MVEMField,
        FieldName: field.(string),
    }

    return expr, nil
}


//TODO: implement the processing logic for: ipmask, object_to_array, printf, tojson, cluster, replace, spath, upper, trim
// mvappend, mvcount, mvdedup, mvfilter, mvfind, mvindex, mvjoin, mvmap, mvrange, mvsort, mvzip, mv_to_json_array
TextExpr <- (opName:("lower" / "upper" / "urldecode") L_PAREN stringExpr:StringExpr R_PAREN ){
    opNameStr, err := transferUint8ToString(opName)
        if err != nil {
        return nil, fmt.Errorf("Spl peg: TextExpr: %v", err)
    }
    node := &structs.TextExpr {
        Op: opNameStr,
        Param: stringExpr.(*structs.StringExpr),
        StrToRemove: "",
    }
    return node, nil
}
/ (opName:("max" / "min") L_PAREN firstVal:StringExpr rest:(COMMA StringExpr)* R_PAREN ) {
    opNameStr, err := transferUint8ToString(opName)
    if err != nil {
        return nil, fmt.Errorf("Spl peg: TextExpr: %v", err)
    }
    if rest == nil {
        return firstVal, nil
    }
    restSlice := rest.([]any)
    values := make([]*structs.StringExpr, 1 + len(restSlice))
    values[0] = firstVal.(*structs.StringExpr)

    for i := range restSlice {
        stringAtom := restSlice[i].([]any)
        values[i + 1] = stringAtom[1].(*structs.StringExpr)
    }
    node := &structs.TextExpr {
        Op: opNameStr,
        ValueList: values,
    }
    return node, nil
}
/ (opName:("mvcount") L_PAREN multiValueExpr:MultiValueExpr R_PAREN) {
    opNameStr, err := transferUint8ToString(opName)
    if err != nil {
        return nil, fmt.Errorf("Spl peg: TextExpr: %v", err)
    }
    node := &structs.TextExpr {
        Op: opNameStr,
        MultiValueExpr: multiValueExpr.(*structs.MultiValueExpr),
    }
    return node, nil
}
/ (opName:("mvjoin") L_PAREN multiValueExpr:MultiValueExpr COMMA delim:StringExpr R_PAREN) {
    opNameStr, err := transferUint8ToString(opName)
    if err != nil {
        return nil, fmt.Errorf("Spl peg: TextExpr: %v", err)
    }
    node := &structs.TextExpr {
        Op: opNameStr,
        MultiValueExpr: multiValueExpr.(*structs.MultiValueExpr),
        Delimiter: delim.(*structs.StringExpr),
    }
    return node, nil
}
/ (opName:("mvfind") L_PAREN multiValueExpr:MultiValueExpr COMMA regexPattern:StringExpr R_PAREN) {
    opNameStr, err := transferUint8ToString(opName)
    if err != nil {
        return nil, fmt.Errorf("spl peg: TextExpr: %v", err)
    }
    regex, ok := regexPattern.(*structs.StringExpr)
    if !ok {
        return nil, fmt.Errorf("spl peg: regexPattern type assertion to StringExpr failed")
    }

    gobRegex := toputils.GobbableRegex{}
	err = gobRegex.SetRegex(regex.RawString)
    if err != nil {
        return nil, fmt.Errorf("spl peg: Regex compile: %v", err)
    }

    node := &structs.TextExpr {
        Op: opNameStr,
        MultiValueExpr: multiValueExpr.(*structs.MultiValueExpr),
        Regex: &gobRegex,
    }
    return node, nil
}

/ (opName:("substr") L_PAREN stringExpr:StringExpr COMMA startIndex:NumericExpr lengthParam:(COMMA NumericExpr)? R_PAREN) {
    opNameStr, err := transferUint8ToString(opName)
    if err != nil {
        return nil, fmt.Errorf("Spl peg: TextExpr: %v", err)
    }
    var lengthConverted *structs.NumericExpr
    if lengthParam != nil {
        lengthSlice, ok := lengthParam.([]interface{})
        if ok && len(lengthSlice) > 1 {
            length, ok := lengthSlice[1].(*structs.NumericExpr)
            if ok {
                lengthConverted = length
            } else {
                return nil, fmt.Errorf("Spl peg: TextExpr: Unable to assert length as *structs.NumericExpr")
            }
        }
    }
    node := &structs.TextExpr {
        Op: opNameStr,
        Param: stringExpr.(*structs.StringExpr),
        StartIndex: startIndex.(*structs.NumericExpr),
        LengthExpr: lengthConverted,
    }
    return node, nil
}
/ "tostring" L_PAREN value:ValueExpr format:(COMMA StringExpr)? R_PAREN {
    var formatExpr *structs.StringExpr
    if format != nil {
        formatSlice := format.([]interface{})
        formatExpr, _ = formatSlice[1].(*structs.StringExpr)
    }
    return &structs.TextExpr{
        IsTerminal: false,
        Op:         "tostring",
        Val:        value.(*structs.ValueExpr),
        Param:     formatExpr,
    }, nil
}
/ (opName:("ltrim" / "rtrim" / "trim") L_PAREN expr:(StringExpr) strToRemoveExpr:(StrToRemoveExpr)? R_PAREN) {
    opNameStr, err := transferUint8ToString(opName)
    if err != nil {
        return nil, fmt.Errorf("Spl peg: TextExpr: %v", err)
    }

    strToRemove := " \t"
    if strToRemoveExpr != nil {
        strToRemove = strToRemoveExpr.(string)
    }

    node := &structs.TextExpr {
        Op: opNameStr,
        Param: expr.(*structs.StringExpr),
        StrToRemove: removeQuotes(strToRemove),
    }

    return node, nil
}
/ "spath" L_PAREN inputField:FieldNameStartWith_ COMMA path:(QuotedPathString / UnquotedPathValue) R_PAREN {
    pathExpr := path.(*SPathFieldExpr)
    return &structs.TextExpr{
        Op: "spath",
        SPathExpr: &structs.SPathExpr{
            InputColName: inputField.(string),
            Path: pathExpr.PathValue,
            IsPathFieldName: pathExpr.IsPathFieldName,
        },
    }, nil
}
/ "ipmask" L_PAREN mask:StringExpr COMMA ip:ValueExpr R_PAREN {
    return &structs.TextExpr{
        Op: "ipmask",
        Val: ip.(*structs.ValueExpr),
        Param: mask.(*structs.StringExpr),
    }, nil
}
/ "object_to_array" L_PAREN obj:ValueExpr COMMA key:QuotedString COMMA value:QuotedString R_PAREN {
    stringExpr := &structs.StringExpr {
        StringExprMode: structs.SEMRawStringList,
        StringList: []string{key.(string), value.(string)},
    }
    return &structs.TextExpr{
        Op: "object_to_array",
        Val: obj.(*structs.ValueExpr),
        Param: stringExpr,
    }, nil
}
/ "printf" L_PAREN format:StringExpr rest:(COMMA StringExpr)* R_PAREN {
    textExpr := &structs.TextExpr{
        Op: "printf",
        Param: format.(*structs.StringExpr),
    }
    if rest != nil {
        restSlice := rest.([]any)
        valueList := make([]*structs.StringExpr, len(restSlice))

        for i := range restSlice {
            valueAtom := restSlice[i].([]any)
            valueList[i] = valueAtom[1].(*structs.StringExpr)
        }
        textExpr.ValueList = valueList
    }

    return textExpr, nil
}
/ "tojson" L_PAREN containInternalFields:(("true" / "false") "()")? R_PAREN {
    expr := &structs.StringExpr {
        StringExprMode: structs.SEMRawString,
        RawString: "true", // default value
    }

    if containInternalFields != nil {
        restSlice := containInternalFields.([]any)
        containInternalFieldsStr, err := transferUint8ToString(restSlice[0])
        if err != nil {
            return nil, fmt.Errorf("Spl peg: TextExpr: %v", err)
        }
        if containInternalFieldsStr == "false" {
            expr.RawString = "false"
        }
    }

    return &structs.TextExpr{
        Op: "tojson",
        Param: expr,
    }, nil
}
/ "cluster" L_PAREN field:EvalFieldToRead threshold:(COMMA "threshold:" FloatAsString)? match:(COMMA "match:" ("termlist" / "termset" / "ngramset"))? delims:(COMMA "delims:" QuotedString)? R_PAREN {
    textExpr := &structs.TextExpr {
        Op: "cluster",
    }

    cluster := &structs.Cluster {
        Field: field.(string),
        Threshold: 0.8,
        Match: "termlist",
    }

    if threshold != nil {
        slice := threshold.([]interface{})
        thresholdStr := slice[2].(string)
        val, err := strconv.ParseFloat(thresholdStr, 64)
        if err != nil {
            return nil, fmt.Errorf("Spl peg: TextExpr: invalid threshold: %v", thresholdStr)
        }
        cluster.Threshold = val
    }

    if match != nil {
        slice := match.([]interface{})
        matchStr, err := transferUint8ToString(slice[2])
        if err != nil {
            return nil, fmt.Errorf("Spl peg: TextExpr: %v", err)
        }
        cluster.Match = matchStr
    }

    if delims != nil {
        slice := delims.([]interface{})
        delimsStr := slice[2].(string)
        cluster.Delims = delimsStr
    }

    textExpr.Cluster = cluster

    return textExpr, nil
}
/ "getfields" L_PAREN filter:(StringExpr)? R_PAREN {
    textExpr := &structs.TextExpr {
        Op: "getfields",
    }

    if filter != nil {
        textExpr.Param = filter.(*structs.StringExpr)
    }

    return textExpr, nil
}
/ "typeof" L_PAREN valueExpr:ValueExpr R_PAREN {
    return &structs.TextExpr {
        Op: "typeof",
        Val: valueExpr.(*structs.ValueExpr),
    }, nil
}
/ "replace" L_PAREN val:ValueExpr COMMA regex:StringExpr COMMA replacement:StringExpr R_PAREN {
    return &structs.TextExpr {
        Op: "replace",
        Val: val.(*structs.ValueExpr),
        ValueList: []*structs.StringExpr{regex.(*structs.StringExpr), replacement.(*structs.StringExpr)},
    }, nil
}
/ "strftime" L_PAREN val:ValueExpr COMMA format:StringExpr R_PAREN {
    return &structs.TextExpr{
        Op: "strftime",
        Val: val.(*structs.ValueExpr),
        Param: format.(*structs.StringExpr),
    }, nil
}

/ "strptime" L_PAREN val:ValueExpr COMMA format:StringExpr R_PAREN {
    return &structs.TextExpr{
        Op: "strptime",
        Val: val.(*structs.ValueExpr),
        Param: format.(*structs.StringExpr),
    }, nil
}

QuotedPathString <- str:QuotedString {
    return &SPathFieldExpr{
        PathValue: removeQuotes(str),
        IsPathFieldName: false,
    }, nil
}

UnquotedPathValue <- str:UnquotedString {
    return &SPathFieldExpr{
        PathValue: removeQuotes(str),
        IsPathFieldName: true,
    }, nil
}

StrToRemoveExpr <- COMMA strToRemove:String {
    return strToRemove, nil
}

// From https://docs.splunk.com/Documentation/Splunk/9.1.0/SearchReference/Eval#Syntax
// Returns the field as a string with no quotation marks.
EvalFieldToRead <- [a-zA-Z_]+ !("(") {
    return string(c.text), nil
}
/ "'" field:FieldName "'" {
    return field, nil
}

// Returns *structs.QueryAggregators
WhereBlock <- PIPE CMD_WHERE condition:BoolExpr {
    queryAgg := &structs.QueryAggregators {
        PipeCommandType: structs.OutputTransformType,
        OutputTransforms: &structs.OutputTransforms {
            FilterRows: condition.(*structs.BoolExpr),
        },
        WhereExpr: condition.(*structs.BoolExpr),
    }

    return queryAgg, nil
}

// Returns *structs.BoolExpr
BoolExpr <- expr:BoolExprLevel4 {
    return expr, nil
}

// Returns *structs.BoolExpr
BoolExprLevel4 <- first:BoolExprLevel3 rest:(OR BoolExprLevel3)* {
    if rest == nil {
        return first, nil
    }

    cur := first.(*structs.BoolExpr)
    for _, v := range rest.([]any) {
        opAndClause := v.([]any)
        cur = &structs.BoolExpr {
            IsTerminal: false,
            BoolOp: structs.BoolOpOr,
            LeftBool: cur,
            RightBool: opAndClause[1].(*structs.BoolExpr),
        }
    }

    return cur, nil
}

// Returns *structs.BoolExpr
BoolExprLevel3 <- first:BoolExprLevel2 rest:(AND BoolExprLevel2)* {
    if rest == nil {
        return first, nil
    }

    cur := first.(*structs.BoolExpr)
    for _, v := range rest.([]any) {
        opAndClause := v.([]any)
        cur = &structs.BoolExpr {
            IsTerminal: false,
            BoolOp: structs.BoolOpAnd,
            LeftBool: cur,
            RightBool: opAndClause[1].(*structs.BoolExpr),
        }
    }

    return cur, nil
}

// Returns *structs.BoolExpr
BoolExprLevel2 <- NOT L_PAREN first:BoolExprLevel1 R_PAREN {
    cur := &structs.BoolExpr {
        IsTerminal: false,
        BoolOp: structs.BoolOpNot,
        LeftBool: first.(*structs.BoolExpr),
        RightBool: nil,
    }

    return cur, nil
}
/ first:BoolExprLevel1 {
    return first, nil
}

// Returns *structs.BoolExpr
BoolExprLevel1 <- L_PAREN first:BoolExprLevel4 R_PAREN {
    return first, nil
}
/ expr: (EvalComparisonExpr / BoolComparisonExpr) {
    return expr, nil
}

//TODO: implement the processing logic for: searchmatch, isnotnull, isnum
EvalComparisonExpr <- (op:("isbool" / "isint" / "isstr" / "isnull" / "isnotnull" / "isnum" / "searchmatch") L_PAREN value:ValueExpr R_PAREN ) {
    opNameStr, err := transferUint8ToString(op)
    if err != nil {
        return nil, fmt.Errorf("Spl peg: BoolExpr: %v", err)
    }
    expr := &structs.BoolExpr {
        IsTerminal: true,
        LeftValue: value.(*structs.ValueExpr),
        RightValue: nil,
        ValueOp: opNameStr,
    }

    if opNameStr == "searchmatch" {
        valExpr := value.(*structs.ValueExpr)
        if valExpr.StringExpr == nil {
            return nil, fmt.Errorf("Spl peg: Searchmatch should only have string values as argument")
        }

        fieldsList, err := SearchMatchGetFields(valExpr.StringExpr.RawString)
        if err != nil {
            return nil, err
        }

        valExpr.StringExpr.StringExprMode = structs.SEMFieldList
        valExpr.StringExpr.FieldList = fieldsList
        expr.LeftValue = valExpr
    }
    
    return expr, nil
}
/ opName:("like" / "Like" / "match" / "cidrmatch") L_PAREN leftValue:ValueExpr COMMA rightValue:ValueExpr R_PAREN {
    opNameStr, err := transferUint8ToString(opName)
    if err != nil {
        return nil, fmt.Errorf("Spl peg: BoolExpr: %v", err)
    }
    expr := &structs.BoolExpr {
        IsTerminal: true,
        LeftValue: leftValue.(*structs.ValueExpr),
        RightValue: rightValue.(*structs.ValueExpr),
        ValueOp: opNameStr,
    }
    return expr, nil
}
/ left:ValueExpr SPACE "in" L_PAREN valueToJudge:ValueExpr rest:(COMMA ValueExpr)* R_PAREN {
    restSlice := rest.([]any)
    slice := make([]*structs.ValueExpr, 1 + len(restSlice))
    slice[0] = valueToJudge.(*structs.ValueExpr)

    for i := range restSlice {
        valueAtom := restSlice[i].([]any)
        slice[i + 1] = valueAtom[1].(*structs.ValueExpr)
    }

    expr := &structs.BoolExpr {
        IsTerminal: true,
        LeftValue: left.(*structs.ValueExpr),
        ValueList: slice,
        ValueOp: "in",
    }
    return expr, nil
}
// For this in use case: if(in(<value>, [<list>]), "true_value", "false_value")
/ "in" L_PAREN valueToJudge:ValueExpr rest:(COMMA ValueExpr)* R_PAREN {
    restSlice := rest.([]any)
    slice := make([]*structs.ValueExpr, len(restSlice))

    for i := range restSlice {
        valueAtom := restSlice[i].([]any)
        slice[i] = valueAtom[1].(*structs.ValueExpr)
    }

    expr := &structs.BoolExpr {
        IsTerminal: true,
        LeftValue: valueToJudge.(*structs.ValueExpr),
        ValueList: slice,
        ValueOp: "in",
    }
    return expr, nil
}

BoolComparisonExpr <- left:ValueExpr op:EqualityOrInequality right:ValueExpr {
    expr := &structs.BoolExpr {
        IsTerminal: true,
        LeftValue: left.(*structs.ValueExpr),
        RightValue: right.(*structs.ValueExpr),
        ValueOp: op.(string),
    }

    return expr, nil
}

// Returns *structs.ValueExpr
//
// The order of the choices is important. In particular, we want to parse a
// single field as a VEMField type ValueExpr so that it can be evaluated to
// either a string or float as needed (if the field has float values), rather
// than parsing it as a NumericExpr or ConcatExpr and forcing it to be a float
// or string respectively.
ValueExpr <- condition:ConditionExpr {

    expr := &structs.ValueExpr {
        ValueExprMode: structs.VEMConditionExpr,
        ConditionExpr: condition.(*structs.ConditionExpr),
    }

    return expr, nil
}
/ L_PAREN (condition:ConditionExpr) R_PAREN {

    expr := &structs.ValueExpr {
        ValueExprMode: structs.VEMConditionExpr,
        ConditionExpr: condition.(*structs.ConditionExpr),
    }

    return expr, nil
}
/ numeric:NumericExpr {

    expr := &structs.ValueExpr {
        ValueExprMode: structs.VEMNumericExpr,
        NumericExpr: numeric.(*structs.NumericExpr),
    }

    return expr, nil
}
/ str:StringExpr {

    expr := &structs.ValueExpr {
        ValueExprMode: structs.VEMStringExpr,
        StringExpr: str.(*structs.StringExpr),
    }

    return expr, nil
}
/ L_PAREN (str:StringExpr) R_PAREN {

    expr := &structs.ValueExpr {
        ValueExprMode: structs.VEMStringExpr,
        StringExpr: str.(*structs.StringExpr),
    }

    return expr, nil
}
/ L_PAREN boolean:BoolExpr R_PAREN {

    expr := &structs.ValueExpr{
        ValueExprMode: structs.VEMBooleanExpr,
        BooleanExpr: boolean.(*structs.BoolExpr),
    }

    return expr, nil
}
/ multiValueExpr:MultiValueExpr {

    expr := &structs.ValueExpr{
        ValueExprMode: structs.VEMMultiValueExpr,
        MultiValueExpr: multiValueExpr.(*structs.MultiValueExpr),
    }

    return expr, nil
}

StringExpr <- text:TextExpr !(EVAL_CONCAT) {
    expr := &structs.StringExpr {
        StringExprMode: structs.SEMTextExpr,
        TextExpr: text.(*structs.TextExpr),
    }

    return expr, nil
}
/ str:QuotedString !(EVAL_CONCAT) {
    expr := &structs.StringExpr {
        StringExprMode: structs.SEMRawString,
        RawString: removeQuotes(str),
    }

    return expr, nil
}
/ field:EvalFieldToRead !(OpPlus / OpMinus / OpMul / OpDiv / OpMod / EVAL_CONCAT / "(") {
    expr := &structs.StringExpr {
        StringExprMode: structs.SEMField,
        FieldName: field.(string),
    }

    return expr, nil
}
/ concat:ConcatExpr {
    expr := &structs.StringExpr {
        StringExprMode: structs.SEMConcatExpr,
        ConcatExpr: concat.(*structs.ConcatExpr),
    }

    return expr, nil
}

// Returns *structs.ConcatExpr
ConcatExpr <- first:ConcatAtom rest:(EVAL_CONCAT ConcatAtom)* !(OpPlus / OpMinus / OpMul / OpDiv / "(") {
    restSlice := rest.([]any)
    slice := make([]*structs.ConcatAtom, 1 + len(restSlice))
    slice[0] = first.(*structs.ConcatAtom)

    for i := range restSlice {
        concatAndAtom := restSlice[i].([]any)
        slice[i + 1] = concatAndAtom[1].(*structs.ConcatAtom)
    }

    expr := &structs.ConcatExpr {
        Atoms: slice,
    }

    return expr, nil
}

// Returns *structs.ConcatAtom
ConcatAtom <- text:TextExpr {
    atom := &structs.ConcatAtom {
        IsField: false,
        Value: "",
        TextExpr: text.(*structs.TextExpr),
    }

    return atom, nil
}
/ str:QuotedString {
    atom := &structs.ConcatAtom {
        IsField: false,
        Value: removeQuotes(str),
    }

    return atom, nil
}
/ number:NumberAsString {
    atom := &structs.ConcatAtom {
        IsField: false,
        Value: number.(string),
    }

    return atom, nil
}
/ field:EvalFieldToRead {
    atom := &structs.ConcatAtom {
        IsField: true,
        Value: field.(string),
    }

    return atom, nil
}

// Returns *structs.NumericExpr
NumericExpr <- expr:NumericExprLevel3 !(EVAL_CONCAT / "\"" ) {
    return expr, nil
}

// Returns *structs.NumericExpr
NumericExprLevel3 <- first:NumericExprLevel2 rest:((OpPlus / OpMinus) NumericExprLevel2)* {
    if rest == nil {
        return first, nil
    }

    cur := first.(*structs.NumericExpr)
    for _, v := range rest.([]any) {
        opAndClause := v.([]any)
        cur = &structs.NumericExpr {
            IsTerminal: false,
            Op: opAndClause[0].(string),
            Left: cur,
            Right: opAndClause[1].(*structs.NumericExpr),
            NumericExprMode: structs.NEMNumericExpr,
        }
    }

    return cur, nil
}

// Returns *structs.NumericExpr
NumericExprLevel2 <- first:NumericExprLevel1 rest:((OpMul / OpDiv / OpMod) NumericExprLevel1)* {
    if rest == nil {
        return first, nil
    }

    cur := first.(*structs.NumericExpr)
    for _, v := range rest.([]any) {
        opAndClause := v.([]any)
        cur = &structs.NumericExpr {
            IsTerminal: false,
            Op: opAndClause[0].(string),
            Left: cur,
            Right: opAndClause[1].(*structs.NumericExpr),
            NumericExprMode: structs.NEMNumericExpr,
        }
    }

    return cur, nil
}

NumericParamExpr <- COMMA expr:NumericExprLevel3 {
    rightNumericExpr, ok := expr.(*structs.NumericExpr)
    if !ok {
        return nil, fmt.Errorf("Failed to assert expr as *structs.NumericExpr")
    }

    return rightNumericExpr, nil
}

// Returns *structs.NumericExpr
NumericExprLevel1 <- L_PAREN expr:NumericExprLevel3 R_PAREN {
    return expr, nil
}
/ numericEvalExpr: NumericEvalExpr {
    return numericEvalExpr, nil
}
/ field:EvalFieldToRead {
    expr := &structs.NumericExpr {
        IsTerminal: true,
        ValueIsField: true,
        Value: field.(string),
        NumericExprMode: structs.NEMNumberField,
    }

    return expr, nil
}
/ number:NumberAsString {
    expr := &structs.NumericExpr {
        IsTerminal: true,
        ValueIsField: false,
        Value: number.(string),
        NumericExprMode: structs.NEMNumber,
    }

    return expr, nil
}

// Todo: implement the processing logic for ops: floor, pi, ln, log, sigfig, pow, random, time, relative_time, strftime
//Currently involves abs, ceil, round, sqrt
NumericEvalExpr <- (opName:("abs" / "ceil" / "ceiling" / "sqrt" / "exact" / "exp" / "floor" / "ln" / "sigfig" / "acosh" / "acos" / "asinh" / "asin" / "atanh" / "atan" / "cosh" / "cos" / "sinh" / "sin" / "tanh" / "tan") L_PAREN expr:(NumericExprLevel3) R_PAREN) {
    leftNumericExpr, ok := expr.(*structs.NumericExpr)
    if !ok {
        return nil, fmt.Errorf("Failed to assert expr as *structs.NumericExpr")
    }

    //transfer []uint8 to string
    strData, ok := opName.([]byte)
    if !ok {
        return nil, fmt.Errorf("opName is not a []byte")
    }

    opNameStr := string(strData)
    node, err := createNumericExpr(opNameStr, leftNumericExpr, nil, structs.NEMNumericExpr)
    if err != nil {
        return nil, err
    }

    return node, nil
}
/ roundExpr:"round" L_PAREN expr:(NumericExprLevel3) roundPrecision:(NumericParamExpr)? R_PAREN {
    leftNumericExpr, ok := expr.(*structs.NumericExpr)
    if !ok {
        return nil, fmt.Errorf("Failed to assert expr as *structs.NumericExpr")
    }

    var rightNumericExpr *structs.NumericExpr
    if roundPrecision != nil {
        rightNumericExpr, ok = roundPrecision.(*structs.NumericExpr)
        if !ok {
            return nil, fmt.Errorf("Failed to assert roundPrecision as *structs.NumericExpr")
        }
    }

    node, err := createNumericExpr("round", leftNumericExpr, rightNumericExpr, structs.NEMNumericExpr)
    if err != nil {
        return nil, err
    }

    return node, nil
}
/ (opName:("now" / "pi" / "random" / "time") L_PAREN R_PAREN) {
    //transfer []uint8 to string
    strData, ok := opName.([]byte)
    if !ok {
        return nil, fmt.Errorf("opName is not a []byte")
    }

    opNameStr := string(strData)
    return &structs.NumericExpr{
        IsTerminal: true,
        Op: opNameStr,
    }, nil
}
/ "tonumber" L_PAREN stringExpr:StringExpr baseExpr:(COMMA NumericExprLevel3)? R_PAREN {
    stringExprConverted, ok := stringExpr.(*structs.StringExpr)
    if !ok {
        return nil, fmt.Errorf("Failed to assert stringExpr as *structs.StringExpr")
    }

    var baseExprConverted *structs.NumericExpr
    if baseExpr != nil {
        baseSlice, ok := baseExpr.([]interface{})
        if ok && len(baseSlice) > 1 {
            if base, ok := baseSlice[1].(*structs.NumericExpr); ok {
                baseExprConverted = base
            } else {
                return nil, fmt.Errorf("Failed to assert base as *structs.NumericExpr")
            }
        }
    }

    node := &structs.NumericExpr {
        IsTerminal: false,
        Op: "tonumber",
        Left: nil,
        Right: baseExprConverted,
        Val: stringExprConverted,
        NumericExprMode: structs.NEMNumericExpr,
    }
    return node, nil
}
/ lenExpr: "len" L_PAREN expr:LenExpr R_PAREN {
    return expr, nil
}
/ (opName:("pow" / "atan2" / "hypot") L_PAREN expr:(NumericExprLevel3) param:(NumericParamExpr) R_PAREN) {
    leftNumericExpr, ok := expr.(*structs.NumericExpr)
    if !ok {
        return nil, fmt.Errorf("Failed to assert expr as *structs.NumericExpr")
    }

    //transfer []uint8 to string
    strData, ok := opName.([]byte)
    if !ok {
        return nil, fmt.Errorf("opName is not a []byte")
    }

    opNameStr := string(strData)

    var rightNumericExpr *structs.NumericExpr
    if param == nil {
        return nil, fmt.Errorf("Function: %v 's param can not be nil", opNameStr)
    }
    rightNumericExpr, ok = param.(*structs.NumericExpr)
    if !ok {
        return nil, fmt.Errorf("Failed to assert param as *structs.NumericExpr")
    }

    node, err := createNumericExpr(opNameStr, leftNumericExpr, rightNumericExpr, structs.NEMNumericExpr)
    if err != nil {
        return nil, err
    }

    return node, nil
}
/ (opName:"log" L_PAREN expr:(NumericExprLevel3) param:(NumericParamExpr)? R_PAREN) {
    leftNumericExpr, ok := expr.(*structs.NumericExpr)
    if !ok {
        return nil, fmt.Errorf("Failed to assert expr as *structs.NumericExpr")
    }

    //transfer []uint8 to string
    strData, ok := opName.([]byte)
    if !ok {
        return nil, fmt.Errorf("opName is not a []byte")
    }

    opNameStr := string(strData)

    var rightNumericExpr *structs.NumericExpr
    if param != nil {
        rightNumericExpr, ok = param.(*structs.NumericExpr)
        if !ok {
            return nil, fmt.Errorf("Failed to assert param as *structs.NumericExpr")
        }
    }

    node, err := createNumericExpr(opNameStr, leftNumericExpr, rightNumericExpr, structs.NEMNumericExpr)
    if err != nil {
        return nil, err
    }

    return node, nil
}
/ opName:("relative_time") L_PAREN expr:(NumericExprLevel3) COMMA QUOTE specifier:(RelativeTimeCommandTimestampFormat) QUOTE R_PAREN {
    opNameStr, err := transferUint8ToString(opName)
    if err != nil {
        return nil, fmt.Errorf("Spl peg: NumericExpr: %v", err)
    }
    node, err := createNumericExpr(opNameStr, expr.(*structs.NumericExpr), nil, structs.NEMNumericExpr)
    if err != nil {
        return nil, err
    }
    relTimeSpecifier, ok := specifier.(utils.RelativeTimeExpr)
    if !ok {
        return nil, fmt.Errorf("specifier is not of type RelativeTimeExpr")
    }
    node.RelativeTime = relTimeSpecifier
    return node, nil
}

LenExpr <- str:QuotedString !(EVAL_CONCAT) {

    leftNumericExpr := &structs.NumericExpr{
        IsTerminal: true,
        ValueIsField: false,
        Value: str.(string),
        NumericExprMode: structs.NEMLenString,
    }

    node, err := createNumericExpr("len", leftNumericExpr, nil, structs.NEMLenString)
    if err != nil {
        return nil, err
    }

    return node, nil
}
/ field:EvalFieldToRead !(OpPlus / OpMinus / OpMul / OpDiv / OpMod / EVAL_CONCAT / "(") {

    leftNumericExpr := &structs.NumericExpr{
        IsTerminal: true,
        ValueIsField: true,
        Value: field.(string),
        NumericExprMode: structs.NEMLenField,
    }

    node, err := createNumericExpr("len", leftNumericExpr, nil, structs.NEMLenField)
    if err != nil {
        return nil, err
    }

    return node, nil
}

HeadOptionNull <- "null" EQUAL boolVal:Boolean {
    optionArg := &HeadOptionArgs{
        argOption: "null",
        headExpr: &structs.HeadExpr{
            Null: boolVal.(bool),
        },
    }

    return optionArg, nil
}

HeadOptionKeeplast <- "keeplast" EQUAL boolVal:Boolean {
    optionArg := &HeadOptionArgs{
        argOption: "keeplast",
        headExpr: &structs.HeadExpr{
            Keeplast: boolVal.(bool),
        },
    }

    return optionArg, nil
}

HeadOptionLimit <- "limit" EQUAL intAsStr:IntegerAsString {
    limit, err := strconv.ParseUint(intAsStr.(string), 10, 64)
    if err != nil {
        return nil, fmt.Errorf("Invalid limit (%v): %v", intAsStr.(string), err)
    }
    optionArg := &HeadOptionArgs{
        argOption: "limit",
        headExpr: &structs.HeadExpr{
            MaxRows: limit,
        },
    }

    return optionArg, nil
}

HeadOptionExpr <- boolExpr:BoolExpr {
    optionArg := &HeadOptionArgs{
        argOption: "boolexpr",
        headExpr: &structs.HeadExpr{
            BoolExpr: boolExpr.(*structs.BoolExpr),
        },
    }

    return optionArg, nil
}

HeadOption <- option:(HeadOptionKeeplast / HeadOptionNull / HeadOptionLimit / HeadOptionExpr) {
    return option, nil
}

HeadOptionList <- first: HeadOption rest: (SPACE HeadOption)* {
    restSlice := rest.([]any)
    optionWasSpecified := make(map[string]bool)
    optionWasSpecified["null"] = false
    optionWasSpecified["keeplast"] = false
    optionWasSpecified["boolexpr"] = false
    optionWasSpecified["limit"] = false

    numOptions := 1 + len(restSlice)

    headExpr := &structs.HeadExpr{}

    for i := 0; i < numOptions; i++ {
        var headOptArg *HeadOptionArgs
        if i == 0 {
            headOptArg = first.(*HeadOptionArgs)
        } else {
            separator := restSlice[i - 1].([]any)
            headOptArg = separator[1].(*HeadOptionArgs)
        }

        argOption := headOptArg.argOption
        val, exist := optionWasSpecified[argOption]
        if !exist {
            return nil, fmt.Errorf("Not a Valid HeadOption: %v", argOption)
        }
        if val {
            return nil, fmt.Errorf("Invalid Syntax, option: %v is already specified", argOption)
        }
        optionWasSpecified[argOption] = true

        switch argOption {
            case "null":
                headExpr.Null = headOptArg.headExpr.Null
            case "keeplast":
                headExpr.Keeplast = headOptArg.headExpr.Keeplast
            case "limit":
                headExpr.MaxRows = headOptArg.headExpr.MaxRows
            case "boolexpr":
                headExpr.BoolExpr = headOptArg.headExpr.BoolExpr
            default:
                return nil, fmt.Errorf("Not a Valid HeadOption: %v", argOption)
        }
    }

    isBoolExpr, _ := optionWasSpecified["boolexpr"]
    if !isBoolExpr {
        isNull, _ := optionWasSpecified["null"]
        if isNull {
            return nil, fmt.Errorf("Invalid Syntax, null option can only be present with condition boolean expression")
        }
        isKeeplast, _ := optionWasSpecified["keeplast"]
        if isKeeplast {
            return nil, fmt.Errorf("Invalid Syntax, keeplast option can only be present with condition boolean expression")
        }
    }

    return headExpr, nil
} 


// Returns *structs.QueryAggregators
HeadBlock <- PIPE CMD_HEAD headExpr:HeadOptionList {
    queryAgg := &structs.QueryAggregators {
        PipeCommandType: structs.OutputTransformType,
        OutputTransforms: &structs.OutputTransforms {
            HeadRequest: headExpr.(*structs.HeadExpr),
        },
        HeadExpr: headExpr.(*structs.HeadExpr),
    }

    return queryAgg, nil
}
/ PIPE CMD_HEAD intAsStr:IntegerAsString {
    limit, err := strconv.ParseUint(intAsStr.(string), 10, 64)
    if err != nil {
        return nil, fmt.Errorf("Invalid limit (%v): %v", intAsStr.(string), err)
    }

    queryAgg := &structs.QueryAggregators {
        PipeCommandType: structs.OutputTransformType,
        OutputTransforms: &structs.OutputTransforms {
            HeadRequest: &structs.HeadExpr{
                MaxRows: limit,
            },
        },
    }

    return queryAgg, nil
}
/ PIPE CMD_HEAD_NO_SPACE {
    queryAgg := &structs.QueryAggregators {
        PipeCommandType: structs.OutputTransformType,
        OutputTransforms: &structs.OutputTransforms {
            HeadRequest: &structs.HeadExpr{
                MaxRows: uint64(10), // From https://docs.splunk.com/Documentation/Splunk/9.1.0/SearchReference/Head
            },
        },
    }

    return queryAgg, nil
}

// Returns *structs.QueryAggregators
TailBlock <- PIPE CMD_TAIL intAsStr:IntegerAsString {
    limit, err := strconv.ParseUint(intAsStr.(string), 10, 64)
    if err != nil {
        return nil, fmt.Errorf("Invalid limit (%v): %v", intAsStr.(string), err)
    }

    tExpr := &structs.TailExpr{
        TailRecords: make(map[string]map[string]interface{}, 0),
        TailRows: limit,
    }

    queryAgg := &structs.QueryAggregators {
        PipeCommandType: structs.OutputTransformType,
        OutputTransforms: &structs.OutputTransforms {
            TailRequest: tExpr,
        },
    }

    return queryAgg, nil
}
/ PIPE CMD_TAIL_NO_SPACE {

    tExpr := &structs.TailExpr{
        TailRecords: make(map[string]map[string]interface{}, 0),
        TailRows: uint64(10), // From https://docs.splunk.com/Documentation/SplunkCloud/9.1.2308/SearchReference/Tail
    }

    queryAgg := &structs.QueryAggregators {
        PipeCommandType: structs.OutputTransformType,
        OutputTransforms: &structs.OutputTransforms {
            TailRequest: tExpr,
        },
    }

    return queryAgg, nil
}


// Parses one or more AggFunctions separated by a comma and space.
// Returns a slice containing all the AggFunctions.
AggregationList <- first:Aggregator rest:((COMMA / SPACE) Aggregator)* {
    // Convert `rest` to a slice. Each element of the slice will be a 2-element
    // slice where the first element is ", " and the second is an Aggregator.
    restSlice := rest.([]any)

    numAggs := 1 + len(restSlice)
    aggsSlice := make([]*aggregator, numAggs)
    aggsSlice[0] = first.(*aggregator)

    for i := 1; i < numAggs; i++ {
        separatorAndAgg := restSlice[i - 1].([]any)
        aggsSlice[i] = separatorAndAgg[1].(*aggregator)
    }

    return aggsSlice, nil
}

Aggregator <- aggFunc:AggFunction asField:AsField? {
    agg := &aggregator{}
    agg.measureAgg = aggFunc.(*structs.MeasureAggregator)

    if asField != nil {
        agg.renameOutputField = true
        agg.outputFieldNewName = asField.(string)
    }

    return agg, nil
}

// For evaluation statements inside aggregate functions:
// 1. min, max, sum, avg, and range can only evaluate boolComparisonExpr, as they need to compute the field value inside the expression. There should be only one field.
// 2. count can evaluate boolExpr because it does not care about the field value inside the expression. It only cares about whether the current row should be counted or not.
// 3. distinctCount and values can evaluate valueExpr because they just need to find out the distinct values of the result of the expression. As for the type of the expression result, it is not important.
AggFunction <- agg:(AggCount / AggPercCommon / AggCommon) {
    return agg, nil
}

// TODO Processing Logic: varp, var, sumsq, stdevp, stdev, rate, range, mode, mean, median, latest_time, latest, last, first, estdc_error, estdc, earliest_time, earliest
CommonAggName <- ("values" / "varp" / "var" / "sumsq" / "sum" / "stdevp" / "stdev" / "rate" / "range" / "mode" / "min" / "median" / "mean" / "max" / 
"list" / "latest_time" / "latest" / "last" / "first" / "estdc_error" / "estdc" / "earliest_time" / "earliest" / "distinct_count" / "dc" / "avg") {
    return string(c.text), nil
}

CommonPercAggName <- ("upperperc" / "exactperc" / "perc") {
    return string(c.text), nil
}

AsField <- AS field: (FieldName / String) {
    fieldStr := field.(string)

    if strings.Contains(fieldStr, "*") {
        return nil, errors.New("The field specified in `AS` cannot contain wildcards")
    }
    
    if fieldStr[0] == '"' && fieldStr[len(fieldStr)-1] == '"' {
        fieldStr = fieldStr[1 : len(fieldStr)-1]
    }

    return fieldStr, nil
}

AggCount <- ("count" / "c") L_PAREN "eval" valueExpr:ValueExpr R_PAREN {
    agg := &structs.MeasureAggregator {
        MeasureCol: "",
        MeasureFunc: utils.Count,
        StrEnc: string(c.text),
        ValueColRequest: valueExpr.(*structs.ValueExpr),
    }

    return agg, nil
}
/ ("count" / "c") L_PAREN field:FieldName R_PAREN {
    agg := &structs.MeasureAggregator {
        MeasureCol: field.(string),
        MeasureFunc: utils.Count,
    }

    return agg, nil
} / ("count" / "c") {
    agg := &structs.MeasureAggregator {
        MeasureCol: "*",
        MeasureFunc: utils.Count,
    }

    return agg, nil
}

AggCommon <- aggName:CommonAggName L_PAREN "eval" valueExpr:ValueExpr R_PAREN {
    measureFunc := GetAggregateFunction(aggName.(string))
    if measureFunc == utils.Invalid {
        return nil, fmt.Errorf("Invalid measure function: %v", string(c.text))
    }

    agg := &structs.MeasureAggregator {
        MeasureCol: "",
        MeasureFunc: measureFunc,
        StrEnc: string(c.text),
        ValueColRequest: valueExpr.(*structs.ValueExpr),
    }

    return agg, nil
}
/ aggName:CommonAggName L_PAREN field:FieldName R_PAREN {
    measureFunc := GetAggregateFunction(aggName.(string))
    if measureFunc == utils.Invalid {
        return nil, fmt.Errorf("Invalid measure function: %v", string(c.text))
    }

    agg := &structs.MeasureAggregator {
        MeasureCol: field.(string),
        MeasureFunc: measureFunc,
    }

    return agg, nil
}

PercentileStr <- numStr:(FloatAsString / IntegerAsString) {
    floatVal, err := strconv.ParseFloat(numStr.(string), 64)
    if err != nil {
        return nil, fmt.Errorf("Invalid percentage value: %v", numStr.(string))
    }
    if floatVal < 0 || floatVal > 100 {
        return nil, fmt.Errorf("Invalid percentage value must be between 0 and 100: %v", numStr.(string))
    }

    return numStr.(string), nil
}

AggPercCommon <- aggName:CommonPercAggName percentileStr:PercentileStr L_PAREN "eval" valueExpr:ValueExpr R_PAREN {
    measureFunc := GetAggregateFunction(aggName.(string))
    if measureFunc == utils.Invalid {
        return nil, fmt.Errorf("Invalid measure function: %v", string(c.text))
    }

    agg := &structs.MeasureAggregator {
        MeasureCol: "",
        MeasureFunc: measureFunc,
        StrEnc: string(c.text),
        ValueColRequest: valueExpr.(*structs.ValueExpr),
        Param: percentileStr.(string),
    }

    return agg, nil
}
/ aggName:CommonPercAggName percentileStr:PercentileStr L_PAREN field:FieldName R_PAREN {
    measureFunc := GetAggregateFunction(aggName.(string))
    if measureFunc == utils.Invalid {
        return nil, fmt.Errorf("Invalid measure function: %v", string(c.text))
    }

    agg := &structs.MeasureAggregator {
        MeasureCol: field.(string),
        MeasureFunc: measureFunc,
        Param: percentileStr.(string),
    }

    return agg, nil
}


FieldWithNumberValue <- keyValuePair:(NamedFieldWithNumberValue / UnnamedFieldWithNumberValue) {
    return keyValuePair, nil
}

NamedFieldWithNumberValue <- key:FieldName op:(EqualityOperator / InequalityOperator) value:Number {
    node := &ast.Node{
        NodeType: ast.NodeTerminal,
        Comparison:ast.Comparison{
            Op: op.(string),
            Field: key.(string),
            Values: value,
        },
    }

    return node, nil
}

UnnamedFieldWithNumberValue <- value:Number {
    node := &ast.Node{
        NodeType: ast.NodeTerminal,
        Comparison:ast.Comparison{
            Op: "=",
            Field: "*",
            Values: value,
        },
    }

    return node, nil
}

FieldWithBooleanValue <- key:FieldName op:EqualityOperator value:Boolean {
    node := &ast.Node{
        NodeType: ast.NodeTerminal,
        Comparison:ast.Comparison{
            Op: op.(string),
            Field: key.(string),
            Values: value,
        },
    }

    return node, nil
}

FieldWithStringValue <- keyValuePair:(NamedFieldWithStringValue / UnnamedFieldWithStringValue) {
    return keyValuePair, nil
}

NamedFieldWithStringValue <- key:FieldName op:EqualityOperator stringSearchReq:(CaseSensitiveString / CaseInsensitiveString) {
    ssr := stringSearchReq.(*StringSearchRequest)
    node := &ast.Node{
        NodeType: ast.NodeTerminal,
        Comparison:ast.Comparison{
            Op: op.(string),
            Field: key.(string),
            Values: ssr.value,
            OriginalValues: ssr.originalValue,
            CaseInsensitive: ssr.caseInsensitive,
        },
    }
    return node, nil
}

UnnamedFieldWithStringValue <- stringSearchReq:(CaseSensitiveString / CaseInsensitiveString) {
    ssr := stringSearchReq.(*StringSearchRequest)
    node := &ast.Node{
        NodeType: ast.NodeTerminal,
        Comparison:ast.Comparison{
            Op: "=",
            Field: "*",
            Values: ssr.value,
            OriginalValues: ssr.originalValue,
            CaseInsensitive: ssr.caseInsensitive,
        },
    }
    return node, nil
}

CaseSensitiveString <- "CASE" L_PAREN value:String R_PAREN {
    return &StringSearchRequest{
        value: value,
        originalValue: value,
        caseInsensitive: false,
    }, nil
}

CaseInsensitiveString <- value:String {
    return &StringSearchRequest{
        value: strings.ToLower(value.(string)),
        originalValue: value,
        caseInsensitive: true,
    }, nil
}

// Parses one or more FieldNames separated by a comma and space.
// Returns a slice containing all the FieldNames.
FieldNameList <- first:FieldName rest:(COMMA FieldName)* {
    // Convert `rest` to a slice. Each element of the slice will be a 2-element
    // slice where the first element is ", " and the second is a FieldName.
    restSlice := rest.([]any)

    numFieldNames := 1 + len(restSlice)
    fields := make([]string, numFieldNames)
    fields[0] = first.(string)

    for i := 1; i < numFieldNames; i++ {
        separatorAndField := restSlice[i - 1].([]any)
        fields[i] = separatorAndField[1].(string)
    }

    return fields, nil
}

TimeModifiers <- EarliestAndLatest / EarliestOnly

EarliestAndLatest <- CMD_EARLIEST EQUAL earliestTime:(AbsoluteTimestamp / RelativeTimestamp) SPACE CMD_LATEST EQUAL latestTime:(AbsoluteTimestamp / RelativeTimestamp) !. {
    var startEpoch int64 = 0
    var endEpoch int64 = 0
    var err error

    earliestTimeModifier := earliestTime.(ast.TimeModifier)
    latestTimeModifier := latestTime.(ast.TimeModifier)

    currTime := time.Now()
    startEpoch, err = CalculateRelativeTime(earliestTimeModifier, currTime)
    if err != nil {
        return nil, err
	}

    // Apply chained modifiers to the start epoch
    startEpoch, err = applyTimeModifiers(startEpoch, earliestTimeModifier.ChainedOffsets, earliestTimeModifier.ChainedSnaps)
    if err != nil {
        return nil, err
    }

    endEpoch, err = CalculateRelativeTime(latestTimeModifier, currTime)
    if err != nil {
        return nil, err
    }
    endEpoch, err = applyTimeModifiers(endEpoch, latestTimeModifier.ChainedOffsets, latestTimeModifier.ChainedSnaps)
    if err != nil {
        return nil, err
    }
    
    // Create AST node
    node := &ast.Node{
        NodeType: ast.TimeModifierNode,
        TimeModifiers: &ast.TimeModifiers{
            StartEpoch: uint64(startEpoch),
            EndEpoch: uint64(endEpoch),
        },
    }

    return node, nil
}

EarliestOnly <- CMD_EARLIEST EQUAL earliestTime:(AbsoluteTimestamp / RelativeTimestamp) !. {
    var startEpoch int64 = 0
    var err error

    earliestTimeModifier := earliestTime.(ast.TimeModifier)

    startEpoch, err = CalculateRelativeTime(earliestTimeModifier, time.Now())
    if err != nil {
        return nil, err
    }
    
    startEpoch, err = applyTimeModifiers(startEpoch, earliestTimeModifier.ChainedOffsets, earliestTimeModifier.ChainedSnaps)
    if err != nil {
        return nil, err
    }

    // Create AST node
    node := &ast.Node{
        NodeType: ast.TimeModifierNode,
        TimeModifiers: &ast.TimeModifiers{
            StartEpoch: uint64(startEpoch),
            EndEpoch: uint64(time.Now().UnixMilli()),
        },
    }

    return node, nil
}

RelIntegerAsString <- [-+][0-9]* {
    return string(c.text), nil
}

WeekSnap <- ('w'[0-7]) {
    return string(c.text), nil
}

RelTimeUnit <- timeUnit:(AllTimeScale) {
    if utils.IsSubseconds(timeUnit.(utils.TimeUnit)) {
        return nil, fmt.Errorf("Relative Time Format does not support subseconds")
    }
    return strconv.Itoa(int(timeUnit.(utils.TimeUnit))), nil
}

Snap <- '@' snap:(WeekSnap / RelTimeUnit) {
    return snap.(string), nil
}

Offset <- off:(RelIntegerAsString) tuOff:(RelTimeUnit) {
    var offsetNum int64 = 0
    var err error
    offStr := off.(string)
    if offStr == "+" {
        offsetNum = 1
    } else if offStr == "-" {
        offsetNum = -1
    } else {
        offsetNum, err = strconv.ParseInt(offStr, 10, 64)
        if err != nil {
            return nil, fmt.Errorf("Invalid Relative Time Format time unit value: (%v): , err: %v", offStr, err)
        }
    }

    timeUnit, err := strconv.Atoi(tuOff.(string))
    if err != nil {
        return nil, fmt.Errorf("Invalid Time Unit value: (%v), err: %v", tuOff.(string), err)
    }

    relTimeOffset := ast.RelativeTimeOffset{
        Offset: offsetNum,
        TimeUnit: utils.TimeUnit(timeUnit),
    }

    return relTimeOffset, nil
}

ChainedRelativeTimestamp <- first:(Offset / Snap) rest:((Offset / Snap)*) {
    var offsets []ast.RelativeTimeOffset
    var snaps []string

    // Append zero values to ensure corresponding offsets and snaps
    // This ensures that each snap and offset correspond to the same index
    appendDefaultValues := func() {
        if len(offsets) > len(snaps) {
            snaps = append(snaps, "")
        } else if len(snaps) > len(offsets) {
            offsets = append(offsets, ast.RelativeTimeOffset{})
        }
    }

    // Process the first element
    if first != nil {
        switch v := first.(type) {
        case ast.RelativeTimeOffset:
            offsets = append(offsets, v)
            snaps = append(snaps, "") // Append default value for Snap
        case string:
            snaps = append(snaps, v)
            offsets = append(offsets, ast.RelativeTimeOffset{}) // Append default value for Offset
        }
    }

    // Process the rest of the elements
    restSlice := rest.([]any)
    for _, item := range restSlice {
        switch v := item.(type) {
        case ast.RelativeTimeOffset:
            offsets = append(offsets, v)
            appendDefaultValues() // Ensure corresponding Snap
        case string:
            snaps = append(snaps, v)
            appendDefaultValues() // Ensure corresponding Offset
        }
    }

    timeModifier := ast.TimeModifier{
        ChainedOffsets: offsets,
        ChainedSnaps: snaps,
    }

    return timeModifier, nil
}

RelativeTimestamp <- defaultTime:("now" / "1")? chained:(ChainedRelativeTimestamp)? {

    if defaultTime != nil {
        if chained != nil {
            return nil, fmt.Errorf("Invalid Relative timestamp, cannot combine default with chained offsets/snaps")
        }
        defTime, err := transferUint8ToString(defaultTime)
        if err != nil {
            return nil, fmt.Errorf("Spl peg: Relative timestamp for default time, err: %v", err)
        }

        timeModifier := ast.TimeModifier{
            AbsoluteTime: defTime,
        }

        return timeModifier, nil
    }

    if chained == nil {
        return nil, fmt.Errorf("Invalid Relative Time Format: Need chained offsets or snaps")
    }

    return chained, nil
}

RelativeTimeCommandTimestampFormat <- offset:(Offset)? snapParam:(Snap)? {

    if offset == nil && snapParam == nil {
        return nil, fmt.Errorf("Invalid Relative Time Format: Need either offset or snap param")
    }

    relTimeOffset := utils.RelativeTimeExpr{}
    snap := ""
    if snapParam != nil {
        snap = snapParam.(string)
    }

    if offset != nil {
        relTimeOffset.Offset = offset.(ast.RelativeTimeOffset).Offset
        relTimeOffset.TimeUnit = offset.(ast.RelativeTimeOffset).TimeUnit
    } 

    timeModifier := utils.RelativeTimeExpr{
		Offset: relTimeOffset.Offset,
		Snap:   snap,
		TimeUnit: relTimeOffset.TimeUnit,
    }

    return timeModifier, nil
}


FullTimeStamp <- [0-9][0-9] '/' [0-9][0-9] '/' [0-9][0-9][0-9][0-9] ':' [0-9][0-9] ':' [0-9][0-9] ':' [0-9][0-9] {
    return string(c.text), nil
}

AbsoluteTimestamp <- timestamp:FullTimeStamp {
    relTimeModifier := ast.TimeModifier{
        AbsoluteTime: timestamp.(string),
    }
    return relTimeModifier, nil
}

// From https://docs.splunk.com/Documentation/Splunk/7.3.1/Knowledge/Aboutregularexpressionswithfieldextractions
// This allows wildcards in a FieldName, but wildcard fields are not allowed in
// some places; those rules should check whether the field has a wildcard.
FieldName <- [a-zA-Z0-9:*][a-zA-Z0-9:_.*]* {
    return string(c.text), nil
}

FieldNameStartWith_ <- [a-zA-Z0-9:_.*][a-zA-Z0-9:_.*]* {
    return string(c.text), nil
}

String <- str:(QuotedString / UnquotedString) {
    return str, nil
}

QuotedString <- '"' [^"]* '"' {
    // The returned string has quotes as the first and last character.
    return string(c.text), nil
}

UnquotedString <- ("*" / (!(MAJOR_BREAK / "|" / EOF) .))+ {
    // Return the string wrapped in quotes.
    str := "\"" + string(c.text) + "\""
    return str, nil
}


AllowedChar <- [a-zA-Z0-9:_{}@.] / ("{" [0-9]* "}")

UnquotedStringWithTemplateWildCard <- (AllowedChar / !(MAJOR_BREAK / "|" / EOF) .)+ {
    return string(c.text), nil
}

Boolean <- ("true" / "false") {
    boolValue, _ := strconv.ParseBool(string(c.text))
    return boolValue, nil
}

//Can recognize fieldName or Regex Pattern for Rename Block
RenamePattern <- [a-zA-Z0-9_*]+ {
    return string(c.text), nil
}

Number <- number:NumberAsString {
    return json.Number(number.(string)), nil
}

// If a number isn't followed by a space, ")", comma, or EOF, we probably want
// to fail and parse it as a string instead.
NumberAsString <- number:(FloatAsString / IntegerAsString) &(SPACE / "|" / ")" / "," / EOF) {
    return number, nil
}

// Allow leading zeros, a "+" before the number, and a decimal point before
// the first digit.
FloatAsString <- [-+]? [0-9]* "." [0-9]+ {
    return string(c.text), nil
}

// Allow leading zeros and a "+" before the number.
IntegerAsString <- [-+]? [0-9]+ {
    return string(c.text), nil
}

PositiveIntegerAsString <- [0-9]+ {
    return string(c.text), nil
}

PositiveInteger <- intStr:PositiveIntegerAsString {
    num, err := strconv.ParseUint(intStr.(string), 10, 64)
    if err != nil {
        return nil, fmt.Errorf("Spl peg: Invalid Positive Integer value: (%v): , err: %v", intStr.(string), err)
    }
    return num, nil
}

EqualityOperator <- EMPTY_OR_SPACE op:("=" / "!=") EMPTY_OR_SPACE {
    opStr, err := transferUint8ToString(op)
    if err != nil {
        return nil, fmt.Errorf("Spl peg: EqualityOperator: %v", err)
    }
    return opStr, nil
}

InequalityOperator <- EMPTY_OR_SPACE op:("<=" / "<" / ">=" / ">") EMPTY_OR_SPACE {
    opStr, err := transferUint8ToString(op)
    if err != nil {
        return nil, fmt.Errorf("Spl peg: InequalityOperator: %v", err)
    }
    return opStr, nil
}

EqualityOrInequality <- op:EqualityOperator {
    return op, nil
}
/ op:InequalityOperator {
    return op, nil
}

OpPlus <- EMPTY_OR_SPACE "+" EMPTY_OR_SPACE {
    return "+", nil
}

OpMinus <- EMPTY_OR_SPACE "-" EMPTY_OR_SPACE {
    return "-", nil
}

OpMul <- EMPTY_OR_SPACE "*" EMPTY_OR_SPACE {
    return "*", nil
}

OpDiv <- EMPTY_OR_SPACE "/" EMPTY_OR_SPACE {
    return "/", nil
}

OpMod <- EMPTY_OR_SPACE "%" EMPTY_OR_SPACE {
    return "%", nil
}

// Add Empty space here
Second <- ("seconds" / "second" / "secs" / "sec" / "s") {
    return utils.TMSecond, nil
}

Minute <- ("minutes" / "minute" / "mins" / "min" / "m") {
    return utils.TMMinute, nil
}

Hour <- ("hours" / "hour" / "hrs" / "hr" / "h") {
    return utils.TMHour, nil
}

Day <- ("days" / "day" / "d") {
    return utils.TMDay, nil
}

Week <- ("weeks" / "week" / "w") {
    return utils.TMWeek, nil
}

Month <- ("months" / "month" / "mon") {
    return utils.TMMonth, nil
}

Quarter <- ("quarters" / "quarter" / "qtrs" / "qtr" / "q") {
    return utils.TMQuarter, nil
}

Year <- ("years" / "year" / "yrs" / "yr" / "y") {
    return utils.TMYear, nil
}

// Might not has effect for 'us', because smallest time unit for timestamp in siglens is ms
Subseconds <- ("us" / "ms" / "cs" / "ds") {
    timeUnit, err := utils.ConvertSubseconds(string(c.text))
    if err != nil {
        return nil, fmt.Errorf("Spl peg: Subseconds: %v", err)
    }
    return timeUnit, nil
}

// Returns *structs.QueryAggregators
TransactionBlock <- PIPE CMD_TRANSACTION txnOptions:TransactionOptions {
    queryAgg := &structs.QueryAggregators{
        PipeCommandType: structs.TransactionType,
        TransactionArguments: txnOptions.(*structs.TransactionArguments),
    }
    return queryAgg, nil
}

// The TransactionDefinitionOptionsList will consist of all the Transaction Options
TransactionOptions <- txnOptions:TransactionDefinitionOptionsList?  {

    transactionRequest := &structs.TransactionArguments{}
     
    if txnOptions != nil {
        txnArgs := txnOptions.(*TxnArgs).arguments
        transactionRequest.Fields = txnArgs.Fields
        transactionRequest.StartsWith = txnArgs.StartsWith
        transactionRequest.EndsWith = txnArgs.EndsWith
    }

    return transactionRequest, nil
}


TransactionDefinitionOptionsList <- first:TransactionDefinitionOption rest:(SPACE TransactionDefinitionOption)* {

    restSlice := rest.([]any)
    txnArgs := &TxnArgs{
        argOption: "txn-definition",
        arguments: &structs.TransactionArguments{},
    }

    numArgs := 1 + len(restSlice)

    for i := 0; i < numArgs; i++ {
        var txnArg *TxnArgs
        if i == 0 {
            txnArg = first.(*TxnArgs)
        } else {
            separatorAndArg := restSlice[i - 1].([]any)
            txnArg = separatorAndArg[1].(*TxnArgs)
        }
        argOption := txnArg.argOption

        switch argOption {
            case "fields":
                txnArgs.arguments.Fields = txnArg.arguments.Fields
            case "startswith": 
                txnArgs.arguments.StartsWith = txnArg.arguments.StartsWith
            case "endswith":
                txnArgs.arguments.EndsWith = txnArg.arguments.EndsWith
            default: 
                return nil, fmt.Errorf("Not a Valid Transaction Argument option")
        }
    }

    return txnArgs, nil
}

TransactionDefinitionOption <- option:(TransactionSpaceSeparatedFieldList / StartsWithOption / EndsWithOption) {
    return option, nil
}

TransactionSpaceSeparatedFieldList <- fields:SpaceSeparatedFieldNameList {
    txnArg := &TxnArgs{
        argOption: "fields",
        arguments: &structs.TransactionArguments{
            Fields: fields.([]string),
        },
    }

    return txnArg, nil
}

StartsWithOption <- "startswith" EQUAL strExpr:TransactionFilterString {
    txnArg := &TxnArgs{
        argOption: "startswith",
        arguments: &structs.TransactionArguments{
            StartsWith: strExpr.(*structs.FilterStringExpr),
        }, 
    }
    return txnArg, nil
}

EndsWithOption <- "endswith" EQUAL strExpr:TransactionFilterString {
    txnArg := &TxnArgs{
        argOption: "endswith",
        arguments: &structs.TransactionArguments{
            EndsWith: strExpr.(*structs.FilterStringExpr),
        },
    }
    return txnArg, nil
}

// Returns structs.FilterStringExpr
TransactionFilterString <- strExpr:(TransactionQuotedString / TransactionEval / TransactionSearch) {
    return strExpr, nil
}

TransactionQuotedString <- str:(TransactionQuotedStringValue / TransactionQuotedStringSearchExpr) {
    return str, nil
}

TransactionQuotedStringSearchExpr <- '"' searchClause:ClauseLevel4 '"' {
    filterStrExpr := &structs.FilterStringExpr{
       SearchNode: searchClause.(*ast.Node),
    }

    return filterStrExpr, nil
}

QuotedStringNoOp <- '"' [^" !(OR / AND)]*  '"' {
    // The returned string has quotes as the first and last character.
    return string(c.text), nil
}

TransactionQuotedStringValue <- str:QuotedStringNoOp {
    filterStrExpr := &structs.FilterStringExpr{
       StringValue: removeQuotes(str.(string)),
    }

    return filterStrExpr, nil
}

TransactionSearch <- expr:ClauseLevel1 {
    
    filterStrExpr := &structs.FilterStringExpr{
       SearchNode: expr.(*ast.Node),
    }

    return filterStrExpr, nil
}

// eval(<bool-expression>)
TransactionEval <- "eval" EMPTY_OR_SPACE L_PAREN condition:BoolExpr R_PAREN {
    filterStrExpr := &structs.FilterStringExpr{
        EvalBoolExpr: condition.(*structs.BoolExpr),
    }

    return filterStrExpr, nil
}

// Returns *structs.QueryAggregators
// Can Add more Multi Value StandAlone Commands by setting => mvQueryAggNode: (MakeMVBlock / MVCombineBlock / ...)
MultiValueBlock <- PIPE mvQueryAggNode: (MakeMVBlock) {
    return mvQueryAggNode, nil
}

MakeMVBlock <- CMD_MAKEMV SPACE mvColOptionExpr: MVBlockOptionsList? EMPTY_OR_SPACE field:FieldName {
    var mvColExpr *structs.MultiValueColLetRequest

    if mvColOptionExpr != nil {
        mvColExpr = mvColOptionExpr.(*structs.MultiValueColLetRequest)
    } else {
        mvColExpr = &structs.MultiValueColLetRequest{}
    }

    mvColExpr.Command = "makemv"
    mvColExpr.ColName = field.(string)

    if mvColExpr.DelimiterString == "" {
        mvColExpr.DelimiterString = " "  // default single space
    }

    queryAgg := &structs.QueryAggregators{
        PipeCommandType: structs.OutputTransformType,
        OutputTransforms: &structs.OutputTransforms{
            LetColumns: &structs.LetColumnsRequest{
                MultiValueColRequest: mvColExpr,
            },
        },
        MakeMVExpr: mvColExpr,
    }

    return queryAgg, nil
}

MVBlockOptionsList <- first: (MVBlockOption) rest: (SPACE MVBlockOption)* {
    restSlice := rest.([]any)

    numOptions := 1 + len(restSlice)

    mvColExpr := &structs.MultiValueColLetRequest{}

    for i := 0; i < numOptions; i++ {
        var currMvColExpr *MultiValueColOptionArgs
        if i == 0 {
            currMvColExpr = first.(*MultiValueColOptionArgs)
        } else {
            separator := restSlice[i - 1].([]any)
            currMvColExpr = separator[1].(*MultiValueColOptionArgs)
        }

        argOption := currMvColExpr.argOption

        switch argOption {
            case "delimiter":
                mvColExpr.DelimiterString = currMvColExpr.mvColExpr.DelimiterString
                mvColExpr.IsRegex = currMvColExpr.mvColExpr.IsRegex
            case "allowempty":
                mvColExpr.AllowEmpty = currMvColExpr.mvColExpr.AllowEmpty
            case "setsv":
                mvColExpr.Setsv = currMvColExpr.mvColExpr.Setsv
            default:
                return nil, fmt.Errorf("Not a Valid MVBlockOption: %v", argOption)
        }
    }

    return mvColExpr, nil
}

MVBlockOption <- option: (DelimOption / AllowEmptyOption / SetSvOption) {
    return option, nil
}

DelimOption <- delimExpr: (StringDelimiter / RegexDelimiter) {
    return delimExpr, nil
}

StringDelimiter <- "delim" EQUAL str:QuotedString {
    mvColOptionArgs := &MultiValueColOptionArgs{
        argOption: "delimiter",
        mvColExpr : &structs.MultiValueColLetRequest{
            DelimiterString: removeQuotes(str),
        },
    }

    return mvColOptionArgs, nil
}

RegexDelimiter <- "tokenizer" EQUAL str:QuotedString {
    pattern := removeQuotes(str)
    _, err := regexp.Compile(pattern)
    if err != nil {
        return nil, fmt.Errorf("Error parsing tokenizer regular expression: %v. Error: %v", pattern, err)
    }

    mvColOptionArgs := &MultiValueColOptionArgs{
        argOption: "delimiter",
        mvColExpr: &structs.MultiValueColLetRequest{
            DelimiterString: pattern,
            IsRegex: true,
        },
    }

    return mvColOptionArgs, nil
}

AllowEmptyOption <- "allowempty" EQUAL boolVal:Boolean {

    mvColOptionArgs := &MultiValueColOptionArgs{
        argOption: "allowempty", 
        mvColExpr: &structs.MultiValueColLetRequest{
            AllowEmpty: boolVal.(bool),
        },
    }

    return mvColOptionArgs, nil
}

SetSvOption <- "setsv" EQUAL boolVal:Boolean {
    mvColOptionArgs := &MultiValueColOptionArgs{
        argOption: "setsv",
        mvColExpr: &structs.MultiValueColLetRequest{
            Setsv: boolVal.(bool),
        },
    }

    return mvColOptionArgs, nil
}

// returns *structs.QueryAggregators
SPathBlock <- PIPE CMD_SPATH spathExpr:SPathArgumentsList? {
    if spathExpr == nil {
        return createSPathExpr("", "", "")
    }
    return spathExpr, nil
}

SPathArgumentsList <- SPACE first:SPathArgument rest:(SPACE SPathArgument)* {

    restSlice := rest.([]any)

    inputField, pathField, outputField := "", "", ""

    numArgs := 1 + len(restSlice)

    for i := 0; i < numArgs; i++ {
        var arg string
        if i == 0 {
            arg = first.(string)
        } else {
            separator := restSlice[i - 1].([]any)
            arg = separator[1].(string)
        }

        switch {
        case strings.HasPrefix(arg, "input="):
            inputField = strings.TrimPrefix(arg, "input=")
        case strings.HasPrefix(arg, "output="):
            outputField = strings.TrimPrefix(arg, "output=")
        case strings.HasPrefix(arg, "path="):
            pathField = strings.TrimPrefix(arg, "path=")
        default:
            return nil, fmt.Errorf("SPathArguments: Invalid Spath Argument: %v", arg)
        }
    }
    
    return createSPathExpr(inputField, pathField, outputField)
}

SPathArgument <- arg:(InputField / OutputField / PathField) {
    return arg, nil
}

InputField <- "input" EQUAL field:FieldName {
    return "input=" + field.(string), nil
}
OutputField <- "output" EQUAL field:FieldName {
    return "output=" + field.(string), nil
}
PathField <- ("path" EQUAL SPathFieldString / SPathFieldString ) {
     pathField := string(c.text)
    if strings.HasPrefix(pathField, "path") {
        pathField = strings.TrimSpace(strings.TrimPrefix(pathField, "path="))
        pathField = strings.TrimSpace(strings.TrimPrefix(pathField, "path ="))
        if pathField != "" && pathField[0] == '"' {
            pathField = removeQuotes(pathField)
        }
    }
    return "path=" + pathField, nil
}

SPathFieldString <- QuotedString / UnquotedStringWithTemplateWildCard

// Returns *structs.QueryAggregators
FormatBlock <- PIPE CMD_FORMAT formatArgExpr:FormatArgumentsList? {
    var formatResultExpr *structs.FormatResultsRequest

    if formatArgExpr != nil {
        formatResultExpr = formatArgExpr.(*structs.FormatResultsRequest)
    } else {
        formatResultExpr = getDefaultFormatResultsExpr()
    }

    queryAgg := &structs.QueryAggregators{
        PipeCommandType: structs.OutputTransformType,
        OutputTransforms: &structs.OutputTransforms{
            LetColumns: &structs.LetColumnsRequest{
                NewColName: "search",
                FormatResults: formatResultExpr,
            },
        },
    }

    return queryAgg, nil
}

FormatArgumentsList <- SPACE first: FormatArgument rest:(SPACE FormatArgument)* {
    restSlice := rest.([]any)

    numOptions := 1 + len(restSlice)

    formatResultExpr := getDefaultFormatResultsExpr()

    for i := 0; i < numOptions; i++ {
        var currFormatExpr *FormatResultsRequestArguments

        if i == 0{
            currFormatExpr = first.(*FormatResultsRequestArguments)
        } else {
            separator := restSlice[i - 1].([]any)
            currFormatExpr = separator[1].(*FormatResultsRequestArguments)
        }

        switch currFormatExpr.argOption {
            case "mvsep":
                formatResultExpr.MVSeparator = currFormatExpr.formatResultExpr.MVSeparator
            case "maxresults":
                formatResultExpr.MaxResults = currFormatExpr.formatResultExpr.MaxResults
            case "emptystr":
                formatResultExpr.EmptyString = currFormatExpr.formatResultExpr.EmptyString
            case "rowColOptions":
                formatResultExpr.RowColOptions = currFormatExpr.formatResultExpr.RowColOptions
            default:
                return nil, fmt.Errorf("not a valid Format Result Argument: %v", currFormatExpr.argOption)
        }
    }

    return formatResultExpr, nil
}

FormatArgument <- argExpr:(FormatSeparator / FormatMaxResults / FormatEmptyStr / FormatRowColOptions) {
    return argExpr, nil
}

FormatSeparator <- "mvsep" EQUAL str:QuotedString {
    return &FormatResultsRequestArguments{
        argOption: "mvsep",
        formatResultExpr: &structs.FormatResultsRequest{
            MVSeparator: removeQuotes(str),
        },
    }, nil
}

FormatMaxResults <- "maxresults" EQUAL numStr:IntegerAsString {
    num, err := strconv.ParseUint(numStr.(string), 10, 64)
    if err != nil {
        return nil, fmt.Errorf("Invalid Max results value is set for format: (%v): Error=%v", numStr.(string), err)
    }
    return &FormatResultsRequestArguments{
        argOption: "maxresults",
        formatResultExpr: &structs.FormatResultsRequest{
            MaxResults: num,
        },
    }, nil
}

FormatEmptyStr <- "emptystr" EQUAL str:QuotedString {
    return &FormatResultsRequestArguments{
        argOption: "emptystr",
        formatResultExpr: &structs.FormatResultsRequest{
            EmptyString: removeQuotes(str),
        },
    }, nil
}

FormatRowColOptions <- rowPrefix:QuotedString SPACE colPrefix:QuotedString SPACE colSeparator:QuotedString SPACE colEnd:QuotedString SPACE rowSeparator:QuotedString SPACE rowEnd:QuotedString {
    rowColOptions := &structs.RowColOptions{
        RowPrefix: removeQuotes(rowPrefix),       
        ColumnPrefix: removeQuotes(colPrefix),    
        ColumnSeparator: removeQuotes(colSeparator), 
        ColumnEnd: removeQuotes(colEnd),       
        RowSeparator: removeQuotes(rowSeparator),    
        RowEnd: removeQuotes(rowEnd),          
    }

    return &FormatResultsRequestArguments{
        argOption: "rowColOptions",
        formatResultExpr: &structs.FormatResultsRequest{
            RowColOptions: rowColOptions,
        },
    }, nil
}

EventCountBlock <- PIPE CMD_EVENTCOUNT eventCountExpr:EventCountArgumentsList? {
	if eventCountExpr == nil {
		return createEventCountExpr([]string{"*"}, true, false, true)
	}
	return eventCountExpr, nil
}

EventCountArgumentsList <- SPACE first:EventCountArgument? rest:(SPACE EventCountArgument)* {

    restSlice := rest.([]any)

    indices := []string{}
    list_vix, report_size, summarize := true, false, true

    numArgs := 0
    if first != nil {
        numArgs++
    }
    numArgs += len(restSlice)

    for i := 0; i < numArgs; i++ {
        var arg string
        if i == 0 && first != nil {
            arg = first.(string)
        } else {
            separator := restSlice[i - 1].([]any)
            arg = separator[1].(string)
        }

        switch {
        case strings.HasPrefix(arg, "index="):
            indices = append(indices, strings.TrimPrefix(arg, "index="))
        case strings.HasPrefix(arg, "list_vix="):
            var err error
            list_vix, err = strconv.ParseBool(strings.TrimPrefix(arg, "list_vix="))
            if err != nil {
                return nil, fmt.Errorf("EventCountArguments: Invalid value for list_vix: %v", err)
            }
        case strings.HasPrefix(arg, "report_size="):
            var err error
            report_size, err = strconv.ParseBool(strings.TrimPrefix(arg, "report_size="))
            if err != nil {
                return nil, fmt.Errorf("EventCountArguments: Invalid value for report_size: %v", err)
            }
        case strings.HasPrefix(arg,"summarize="):
            var err error
            summarize, err = strconv.ParseBool(strings.TrimPrefix(arg, "summarize="))
            if err != nil {
                return nil, fmt.Errorf("EventCountArguments: Invalid value for summarize: %v", err)
            }
        default:
            return nil, fmt.Errorf("EventCountArguments: Invalid EventCount Argument: %v", arg)
        }
    }

    // If no indices were provided, use the default value "*"
    if len(indices) == 0 {
        indices = append(indices, "*")
    }

    return createEventCountExpr(indices, list_vix, report_size, summarize)
}

EventCountArgument <- arg:(IndexField / SummarizeField / ReportSizeField / ListVixField) {
    return arg, nil
}

IndexField <- "index" EQUAL index:IndexName {
    return "index=" + index.(string), nil
}
SummarizeField <- "summarize" EQUAL field:Boolean {
    return "summarize=" + strconv.FormatBool(field.(bool)), nil
}
ReportSizeField <- "report_size" EQUAL field:Boolean {
    return "report_size=" + strconv.FormatBool(field.(bool)), nil
}
ListVixField <- "list_vix" EQUAL field:Boolean {
    return "list_vix=" + strconv.FormatBool(field.(bool)), nil
}

IndexName <- (!SPACE .)+ {
	return string(c.text), nil
}

// return *structs.QueryAggregators
FillNullBlock <- PIPE CMD_FILLNULL valueOption: FillNullValueOption? fields:FillNullFieldList? {
    valueStr := "0"
    fieldList := make([]string, 0)

    if valueOption != nil {
        valueStr = valueOption.(string)
    }

    if fields != nil {
        fieldList = fields.([]string)
    }

    fillNullExpr := &structs.FillNullExpr{
        Value: valueStr,
        FieldList: fieldList,
    }
	fillNullExpr.Records = make(map[string]map[string]interface{}, 0)
	fillNullExpr.FinalCols = make(map[string]bool, 0)

    return &structs.QueryAggregators{
        PipeCommandType: structs.OutputTransformType,
        OutputTransforms: &structs.OutputTransforms{
            LetColumns: &structs.LetColumnsRequest{
                FillNullRequest: fillNullExpr,
            },
        },
        FillNullExpr: fillNullExpr,
    }, nil
}

FillNullValueOption <- SPACE "value" EQUAL str:String {
    return removeQuotes(str), nil
}

FillNullFieldList <- SPACE fieldList:SpaceSeparatedFieldNameList {
    return fieldList, nil
}

MvexpandBlock <- PIPE CMD_MVEXPAND field:MvexpandField limit:MvexpandLimit? {
	limitVal := int64(0) // default value indicating no limit
	var err error
	if limit != nil {
		limitVal, err = strconv.ParseInt(limit.(string), 10, 64)
		if err != nil {
			return nil, fmt.Errorf("Error parsing limit value: %v", err)
		}
	}

	mvexpandExpr := &structs.MultiValueColLetRequest{
		Command: "mvexpand",
		ColName: field.(string),
	}

	if limitVal != 0 {
		mvexpandExpr.Limit = limitVal
	}

    queryAgg := &structs.QueryAggregators{
        PipeCommandType: structs.OutputTransformType,
        OutputTransforms: &structs.OutputTransforms{
            LetColumns: &structs.LetColumnsRequest{
                MultiValueColRequest: mvexpandExpr,
            },
        },
    }
    return queryAgg, nil
}

MvexpandField <- SPACE fieldName:FieldName {
    return fieldName, nil
}

MvexpandLimit <- SPACE "limit" EQUAL intValue:IntegerAsString {
    return intValue, nil
}

WhereClause <- SPACE CMD_WHERE condition:BoolExpr {
    return condition.(*structs.BoolExpr), nil
}

InputLookupOptionAppend <- "append" EQUAL boolVal:Boolean {
    return &InputLookupOptionArgs{
        argOption: "append",
        inputLookupOption: &structs.InputLookup{
            Append: boolVal.(bool),
        },
    }, nil
}

InputLookupOptionStrict <- "strict" EQUAL boolVal:Boolean {
    return &InputLookupOptionArgs{
        argOption: "strict",
        inputLookupOption: &structs.InputLookup{
            Strict: boolVal.(bool),
        },
    }, nil
}

InputLookupOptionStart <- "start" EQUAL posInt:PositiveInteger {
    return &InputLookupOptionArgs{
        argOption: "start",
        inputLookupOption: &structs.InputLookup{
            Start: posInt.(uint64),
        },
    }, nil
}

InputLookupOptionMax <- "max" EQUAL posInt:PositiveInteger {
    return &InputLookupOptionArgs{
        argOption: "max",
        inputLookupOption: &structs.InputLookup{
            Max: posInt.(uint64),
        },
    }, nil
}

InputLookupOption <- inputLookupOption:(InputLookupOptionAppend / InputLookupOptionStrict / InputLookupOptionStart / InputLookupOptionMax) {
    return inputLookupOption, nil
}

InputLookupOptionList <- first: (InputLookupOption) rest:(SPACE InputLookupOption)* {
    restSlice := rest.([]any)
    optionWasSpecified := make(map[string]struct{})
    numOptions := 1 + len(restSlice)

    inputLookupOption := &structs.InputLookup{}

    for i := 0; i < numOptions; i++ {
        var inputLookupOptionArg *InputLookupOptionArgs
        if i == 0 {
            inputLookupOptionArg = first.(*InputLookupOptionArgs)
        } else {
            separator := restSlice[i - 1].([]any)
            inputLookupOptionArg = separator[1].(*InputLookupOptionArgs)
        }

        argOption := inputLookupOptionArg.argOption
        _, exist := optionWasSpecified[argOption]
        if exist {
            return nil, fmt.Errorf("Invalid Syntax, option: %v is already specified", argOption)
        }
        optionWasSpecified[argOption] = struct{}{}

        switch argOption {
            case "append":
                inputLookupOption.Append = inputLookupOptionArg.inputLookupOption.Append
            case "strict":
                inputLookupOption.Strict = inputLookupOptionArg.inputLookupOption.Strict
            case "start":
                inputLookupOption.Start = inputLookupOptionArg.inputLookupOption.Start
            case "max":
                inputLookupOption.Max = inputLookupOptionArg.inputLookupOption.Max
            default:
                return nil, fmt.Errorf("Not a Valid InputLookup Option: %v", argOption)
        }
    }

    return inputLookupOption, nil
}



InputLookupBlock <- PIPE CMD_INPUTLOOKUP inputLookupOption:(InputLookupOptionList SPACE)? filename:(String) whereClause:(WhereClause)? {
    inputLookup := &structs.InputLookup{}
    if inputLookupOption != nil {
        inputLookupOption := inputLookupOption.([]any)
        inputLookup = inputLookupOption[0].(*structs.InputLookup)
    }
    if whereClause != nil {
        inputLookup.WhereExpr = whereClause.(*structs.BoolExpr)
    }
    inputLookup.Filename = removeQuotes(filename.(string))
    if inputLookup.Max == 0 {
        inputLookup.Max = 1000000000
    }

    return &structs.QueryAggregators{
        PipeCommandType: structs.GenerateEventType,
        GenerateEvent: &structs.GenerateEvent{
            InputLookup: inputLookup,
        },
    }, nil
}

InputLookupAggBlock <- inputLookupBlock:InputLookupBlock {
    inputLookup := inputLookupBlock.(*structs.QueryAggregators)
    if !inputLookup.GenerateEvent.InputLookup.Append {
        return nil, fmt.Errorf("An Inputlookup command which is not the first command must have append as true")
    }
    inputLookup.GenerateEvent.InputLookup.HasPrevResults = true
    
    return inputLookup, nil
}

// Definitions for append command options
AppendCmdOption <- option:(ExtendTimeRangeOption / MaxTimeOption / MaxOutOption) {
    return option, nil
}

// Definitions for the individual options within append
ExtendTimeRangeOption <- "extendtimerange" EQUAL boolean:Boolean {
    return &structs.AppendCmdOption{
        OptionType: "extendtimerange",
        Value:      boolean == "true",
    }, nil
}

MaxTimeOption <- "maxtime" EQUAL time:IntegerAsString {
    maxTimeInt, err := strconv.ParseUint(time.(string), 10, 64)
    if err != nil {
        return nil, fmt.Errorf("Invalid maxtime (%v): %v", time.(string), err)
    }
    return &structs.AppendCmdOption{
        OptionType: "maxtime",
        Value:      maxTimeInt,
    }, nil
}

MaxOutOption <- "maxout" EQUAL max:IntegerAsString {
    maxOutInt, err := strconv.ParseUint(max.(string), 10, 64)
    if err != nil {
        return nil, fmt.Errorf("Invalid maxout (%v): %v", max.(string), err)
    }
    return &structs.AppendCmdOption{
        OptionType: "maxout",
        Value:      maxOutInt,
    }, nil
}

// Subsearch definition using the existing SearchBlock rule
Subsearch <- "[" SPACE? search:SearchBlock SPACE? "]" {
    return search, nil
}

// Append command options extended to handle subsearches
AppendCmdOptionsList <- first:AppendCmdOption rest:(SPACE AppendCmdOption)* {
    restSlice := rest.([]any)
    numOptions := 1 + len(restSlice)
    appendCmdOptions := &structs.AppendCmdOptions{}

    for i := 0; i < numOptions; i++ {
        var option *structs.AppendCmdOption
        if i == 0 {
            option = first.(*structs.AppendCmdOption)
        } else {
            option = restSlice[i-1].([]any)[1].(*structs.AppendCmdOption)
        }

        switch option.OptionType {
            case "extendtimerange":
                appendCmdOptions.ExtendTimeRange = option.Value.(bool)
            case "maxtime":
                appendCmdOptions.MaxTime = option.Value.(int)
            case "maxout":
                appendCmdOptions.MaxOut = option.Value.(int)
        }
    }

    return appendCmdOptions, nil
}

// AppendBlock with subsearch handling
AppendBlock <- PIPE CMD_APPEND options:(AppendCmdOption SPACE?)* subsearch:Subsearch {
    appendOptions := &structs.AppendCmdOptions{
        ExtendTimeRange: false,
        MaxTime:         60,
        MaxOut:          50000,
    }

    for _, opt := range options.([]interface{}) {
        if optSlice, ok := opt.([]interface{}); ok {
            for _, appendOption := range optSlice {
                if option, ok := appendOption.(*structs.AppendCmdOption); ok {
                    switch option.OptionType {
                        case "extendtimerange":
                            appendOptions.ExtendTimeRange = option.Value.(bool)
                        case "maxtime":
                            appendOptions.MaxTime = int(option.Value.(uint64))
                        case "maxout":
                            appendOptions.MaxOut = int(option.Value.(uint64))
                        default:
                            return nil, fmt.Errorf("AppendBlock: Unknown OptionType: %v", option.OptionType)
                    }
                } 
            }
        } 
    }

    letColReq := &structs.LetColumnsRequest{
        AppendRequest: &structs.AppendRequest{
            ExtendTimeRange: appendOptions.ExtendTimeRange,
            MaxTime:         appendOptions.MaxTime,
            MaxOut:          appendOptions.MaxOut,
            Subsearch:       subsearch,
        },
    }
    return &structs.QueryAggregators{
        PipeCommandType: structs.OutputTransformType,
        OutputTransforms: &structs.OutputTransforms{
            LetColumns: letColReq,
        },
    }, nil
}


// All commands except CMD_SEARCH
ALLCMD <- (CMD_REGEX / CMD_STATS / CMD_FIELDS / CMD_WHERE / CMD_HEAD_NO_SPACE / CMD_HEAD / CMD_TAIL_NO_SPACE / CMD_TAIL / CMD_EVAL / CMD_REX / CMD_TOP / CMD_RARE / CMD_RENAME / CMD_TIMECHART / CMD_TRANSACTION / CMD_DEDUP / CMD_SORT / CMD_MAKEMV / CMD_SPATH / CMD_FORMAT / CMD_EARLIEST / CMD_LATEST / CMD_EVENTCOUNT / CMD_BIN / CMD_STREAMSTATS / CMD_FILLNULL / CMD_MVEXPAND / CMD_GENTIMES / CMD_INPUTLOOKUP / CMD_APPEND)
CMD_SEARCH <- "search" SPACE
CMD_REGEX <- "regex" SPACE
CMD_STATS <- "stats" SPACE
CMD_STREAMSTATS <- "streamstats" SPACE
CMD_FIELDS <- "fields" SPACE
CMD_WHERE <- "where" SPACE
CMD_HEAD_NO_SPACE <- "head"
CMD_HEAD <- CMD_HEAD_NO_SPACE SPACE
CMD_TAIL_NO_SPACE <- "tail"
CMD_TAIL <- CMD_TAIL_NO_SPACE SPACE
CMD_EVAL <- "eval" SPACE
CMD_REX <- "rex" SPACE
CMD_SORT <- "sort" SPACE
CMD_TOP <- "top"
CMD_RARE <- "rare"
CMD_RENAME <- "rename" SPACE
CMD_TIMECHART <- "timechart" SPACE
CMD_BIN <- "bin" SPACE
CMD_SPAN <- "span"
CMD_TRANSACTION <- "transaction" SPACE
CMD_DEDUP <- "dedup"
CMD_DEDUP_SORTBY <- SPACE "sortby" SPACE
CMD_MAKEMV <- "makemv"
CMD_SPATH <- "spath"
CMD_FORMAT <- "format"
CMD_EARLIEST <- "earliest"
CMD_LATEST <- "latest"
CMD_EVENTCOUNT <- "eventcount"
CMD_FILLNULL <- "fillnull"
CMD_GENTIMES <- "gentimes"
CMD_INPUTLOOKUP <- "inputlookup" SPACE
EVAL_CONCAT <- SPACE? ("." / "+") SPACE?
CMD_MVEXPAND <- "mvexpand"
CMD_APPEND <- "append" SPACE

// Major and Minor breaks from https://docs.splunk.com/Documentation/Splunk/9.0.4/Admin/Segmentersconf
MAJOR_BREAK <- [[\]<>(){}|!;,'"*\n\r \t&?+] / "%21" / "%26" /
               "%2526" / "%3B" / "%7C" / "%20" / "%2B" / "%3D" / "--" /
               "%2520" / "%5D" / "%5B" / "%3A" / "%0A" / "%2C" / "%28" / "%29"
MINOR_BREAK <- [/:=@.$#%_] / "-" / "\\"

// https://community.splunk.com/t5/Splunk-Search/are-search-language-keywords-case-sensitive/m-p/9106
// has some information about case sensitivity.
NOT <- "NOT" SPACE
OR <- SPACE "OR" SPACE
AND <- SPACE "AND" SPACE
PIPE <- EMPTY_OR_SPACE "|" EMPTY_OR_SPACE
AS <- SPACE "AS"i SPACE // Case insensitive
BY <- SPACE "BY"i SPACE // Case insensitive

EQUAL <- EMPTY_OR_SPACE "=" EMPTY_OR_SPACE
COMMA <- EMPTY_OR_SPACE "," EMPTY_OR_SPACE
QUOTE <- '"'
L_PAREN <- "(" EMPTY_OR_SPACE
R_PAREN <- EMPTY_OR_SPACE ")"

EOF <- !.
WHITESPACE <- " " / "\t" / "\n" / "\r"
SPACE <- (WHITESPACE? COMMENT WHITESPACE?) / WHITESPACE+
COMMENT <- "```" (!("```") .)* "```"
EMPTY_OR_SPACE  <- SPACE / ""
SPACE_OR_COMMA <- COMMA / SPACE
